\documentclass[a4paper]{article}

\usepackage{fullpage} % Package to use full page
\usepackage{parskip} % Package to tweak paragraph skipping
\usepackage{tikz} % Package for drawing
\usepackage{amsmath}
\usepackage{hyperref}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\usepackage[MeX]{polski}

\title{Notatki z kursu Sieci Komputerowe}
\author{Małgorzata Dymek}
\date{2018/19, semestr letni}

\begin{document}
\maketitle



% \section{Laboratorium 1}
% Zasady zaliczenia: trzy kolokwia (dwa pisane (adresacja + routing i switching)  + jedno praktyczne ( naprawienie zepsutych rzeczy ) )
% \begin{itemize}
%     \item dwa kolokwia pisemne (20 + 20)
%     \begin{itemize}
%         \item adresacja
%         \item routing i switching
%     \end{itemize}
%     \item kolokwium praktyczne (30)
%     \begin{itemize}
%         \item naprawienie zepsutych rzeczy
%     \end{itemize}
%     \item obecność - 15*2 = 30
% \end{itemize}
% W sumie 100 punktów.
%
% \begin{tabular}{|c|c|}
% \hline
% 0 - 50 & ndst\\
% \hline
% 51 - 60 & dst\\
% \hline
% 61 - 70 & dst+\\
% \hline
% 71 - 80 & db\\
% \hline
% 81 - 90 & db+\\
% \hline
% 91 - 100 & bdb\\
% \hline
% \end{tabular}
%
%
% Bridge - fizyczne połączenie do fizycznej karty sieciowej (kabel rj5) jakby jedna szyna (wszystko do fizycznej wpada do wirtualnej)
% Host only - tylko z komputera bez wyjścia na zewnątrz
% NAP - adres z fizycznego komputera, nie z wirtualki
%
% settings - vnet3 - nr wirtualnego switcha
% brama domyślna - wyjście na świat - pc2
%
% \section{Laboratorium 2}
% Routing
%
% menedżer urządzeń -> nr COMu -> PuTTy serial COM -> konsola - wpisać no ->
%
%
% \begin{itemize}
%     \item Z listwy SERIAL (numer monitora nad) kablem prostym do konsoli routera.
%     \item Z listwy LAN (numer monitora nad) kablem prostym do f0/1
%     \item Z f0/0 kablem prostym do switcha.
%     \item Odpowiednio seriale zgodnie z rysunkiem tymi płaskimi niebieskimi kablami.
%     \item Menedżer urządzeń - sprawdzamy numer COM.
%     \item PuTTy - wpisujemy odpowiedni numer COM.
%
%     \item Cisco
%     enable\\
%     configure terminal\\
%
%     interface x/x\\
%     ip address \textit{IP_addr maska}\\
%     interafce loopback nr \\
%     clock rate – tylko na serialach, nie trzeba ustawiać na Cisco\\
%     encapsulation ppp – ustawienie enkapsulacji (tylko na serialach)\\
%     encapsulation hdlc - ustawienie enkapsulacji (tylko na serialach)\\
%     no shutdown\\
% \end{itemize}



\section{Podstawowe pojęcia}
\textbf{Sieć komputerowa} - zbiór połączonych komputerów i urządzeń z możliwością komunikacji. Obejmują	również	wszystko co	umożliwia
komunikację i współdzielenie zasobów, w szczególności oprogramowanie, protokoły komunikacyjne, media transmisyjne (kable).
\\
Dwie główne kategorie sieci:
\begin{itemize}
    \item \textbf{LAN} - Local Area Networks
    \item \textbf{WAN} - Wide Area Networks
\end{itemize}

Przybliżone  kryterium	 rozróżnienia: odległości między łączonymi	komputerami. Są techlonolgie charakterystyczne dla
sieci	lokalnych (Gigabit Ethernet),	inne dla sieci rozległych (T1,	E1	czy	Frame	Relay).
\\
Inny podział wg kryterium odległości:
\begin{itemize}
    \item \textbf{Nanoscale} – obecnie przedmiot badań, zastosowanie w nanomedycynie (IEEE).
    \item \textbf{NFC} (Near Field Communication) – odległości	rzędu	centymetrów.
    \item \textbf{BAN} (Body Area Network),	\textbf{WBAN} (Wireless	BAN),	inaczej to	BSN	(Body	Sensor	Network) – łączenie	czujników,	„wearable	devices”.
    \item \textbf{PAN} (Personal Area Network) – od centymetrów	do	kilku metrów (bezprzedowowe: IrDA,	Bluetooth,	Wireless USB,	oraz	przewodowe	jak	USB,	FireWire,
Thunderbolt).
    \item \textbf{NAN} (Near-me	Area	Network)	– komunikacja	między	urządzeniami bezprzewodowymi, które	są	blisko	siebie. Ścieżka	komunikacyjna	między	urządzeniami	w	jednej	sieci	NAN	może jednak	być	długa	i	może	nawet	obejmować	technologie	sieci	WAN,	np.	jeśli	do	NAN	należą telefony	zarejestrowane	w	różnych	firmach	telekomunikacyjnych.
    \item \textbf{SAN} (Storage	Area	Network).
    \item \textbf{CAN} – Campus	Area	Network,	sieci	kampusowe.
    \item \textbf{MAN} (Metropolitan	Area	Network)	– obejmuje	obszar	miasta,	dużego	kampusu.
\end{itemize}

\textbf{Internet jest globalną	 siecią	 komputerową} złożoną z	 wielu	 sieci	 komputerowych wykorzystujących	 \textbf{protokół IP} (zestaw protokołów TCP/IP). Od strony	 logicznej	 Internet można	identyfikować	z	\textbf{przestrzenią	adresową	protokołu	IP}	 (są	w użyciu	dwie wersje:	IPv4 i nowsza IPv6).\\
Na	każdą	sieć	komputerową	składają	się	sprzętowe	oraz	programowe	elementy	składowe.

\subsection{Sprzętowe	elementy	składowe	sieci	komputerowych}
Podstawowymi	elementami	sprzętowymi	są:
\begin{itemize}
    \item \textbf{Nośniki	transmisji}	(media	transmisyjne)\\
    Nośniki	 transportu	 sygnałów	 przesyłanych	 przez	 sieć. Są to na przykład kable koncentryczne, tzw.
    skrętki, kable miedziane,  kable	 światłowodowe,	 ale	 też	 przestrzeń (przesyłanie	fal	radiowych,	mikrofal,	światła).
    \item \textbf{Urządzenia	dostępu do	nośnika}\\
    Są odpowiedzialne za	formatowanie danych	tak, by nadawały się do	 przesyłania poprzez nośnik	 transmisji, umieszczanie	 tych	 danych	 w nośniku	transmisji	oraz	odbieranie	odpowiednio zaadresowanych	danych	(np. karty sieciowe w sieci LAN).
    \item \textbf{Urządzenia	wzmacniające,	filtrujące	i	kierujące	przesyłane	sygnały},	np.	przełączniki warstwy	drugiej, routery.\\
    Sygnały	 umieszczane w	 nośniku transmisji ulegają zakłóceniom.
    \begin{itemize}
        \item \textbf{Tłumienie} (osłabienie siły sygnału)\\
        Sposoby unikania tłumienia:  ograniczenie	 długości	 połączeń	 (kabli), zainstalowanie	urządzenia,	które odczytuje	przesyłane	sygnały,	wzmacnia	je	i
        wysyła	z	powrotem	do	sieci.
        \item \textbf{Zniekształcenie} (niepożądanazmiana kształtu przebiegu czasowego)\\
        Przeciwdziałanie	 zniekształceniom polega	 na	 przestrzeganiu	 zaleceń dotyczących	 nośnika	 (odpowiedni typ nośnika, poprawna instalacja, odpowiednie	 długości	 przewodów) oraz korzystaniu z protokołów obsługujących korektę	błędów	transmisji.
    \end{itemize}
    Zadania	filtrujące	i	kierujące	sygnały	spełniają	takie	urządzenia	jak	mosty (pomosty,	bridges już	 raczej	 nie	 używane),	 koncentratory (hubs)	 przełączniki (switches), punkty	 dostępowe (access points), routery (routers),	bramy (gateways).
\end{itemize}

Karty	sieciowe	pakują	dane	w	tzw.	ramki. Ramki	są	podstawowymi	porcjami	danych	przesyłanymi	w	sieciach	komputerowych.


\subsection{Programowe	elementy	składowe	sieci	komputerowych.}
Elementami	programowymi	sieci	są:
\begin{itemize}
    \item \textbf{Protokoły	 komunikacyjne} (sieciowe)\\
    Zestawy standardów i zasad obowiązujących przy	 przesyłaniu danych	przez	sieć. Określają sposoby komunikowania się urządzeń	i	programów.
    \item \textbf{Oprogramowanie	komunikacyjne}\\
    Implementuje protokoły sieciowe. Są to programy	 umożliwiające	 użytkownikom	 korzystanie	 z
    sieci	 komputerowych	 np. program telnet, przeglądarki WWW, klienci pocztowi, oprogramowanie	umożliwiające mapowanie	dysków	sieciowych	itd.
    \item \textbf{Programy	 poziomu	 sprzętowego}\\
    Sterują pracą elementów	 sprzętowych. Sterowniki, programy	 obsługi, mikroprogramy umożliwiające	działanie	takich	urządzeń,	jak	karty	sieciowe.
\end{itemize}

\subsection{Ramki}
Dane przesyłane są w \textbf{porcjach zwanych ramkami}. Urządzenie	zapewniające dostęp	do nośnika przesyła	pewne sygnały, które są \textbf{interpretowane jako bity}. Od strony	logicznej wysyłany	ciąg bitów zawiera	pewne informacje i może	być	podzielony na porcje zwane \textbf{polami}.

Typowa ramka zawiera następujące pola:
\begin{itemize}
    \item ogranicznik początku ramki (jest	to	ustalony	wzór	bitów)
    \item tzw.	adres fizyczny nadawcy (źródła	danych)
    \item adres	fizyczny odbiorcy (miejsca	docelowego)
    \item dane
    \item ogranicznik końca	ramki (sekwencja	kontrolna	ramki).
\end{itemize}
Ogranicznik	 początku ramki być poprzedzony lub może zawierać tzw. \textbf{preambułę}, która w pewnych technologiach sieciowych jest stosowana do synchronizacji nadajnika i
odbiornika. Wielkość pól określana jest w oktetach (8 bitów, uniknięcia niejednoznaczności "bajtu" mogącego mieć więcej bitów). \textbf{Kapsułkowanie} - wstawienie danych do struktury ramki. Istnieją różne formaty ramek, różne sposoby kapsułkowania i różne sposoby fizycznego adresowania komputerów.

\subsection{Topologia sieci lokalnych}
Dwa rodzaje topologii:
\begin{itemize}
    \item Topologie fizyczne
    \item Topologie logiczne
\end{itemize}

Jeżeli przy fizycznej topologii gwiazdy komputer przesyła dane bezpośrednio do komputera docelowego (przełącznik), to mamy logiczną topologię gwiazdy. Jeżeli ramka jest wysyłana do wszystkich dostępnych komputerów (koncentrator), to logicznie jest to topologia magistrali.

\subsubsection{Komunikacja między komputerami}

Założenia:
\begin{itemize}
    \item Komputer źródłowy - Komputer 1: IP1, MAC1
    \item Komputer docelowy - Komputer 2: IP2, MAC2
\end{itemize}
Połączone switchem. Na komputerze docelowym  jest serwer strony WWW2.

Jeżeli na komputerze 1 ktoś spróbuje otworzyć WWW2, to:

\begin{itemize}
    \item Zadziała system DNS: komputer	1 skontaktuje się ze swoim serwerem	DNS i zapyta jaki jest adres IP	komputera związanego z nazwą domenową WW2. Serwer DNS znajdzie	odpowiedni adres w swoich zasobach i odeśle informację do	komputera 1.
    \item Przeglądarka utworzy komunikat (wg protokołu	HTTP).	Do komunikatu zostanie dodany nagłówek	(wg	protokołu TCP),	który zawiera m.in.	port docelowy (standardowo	serwery
    WWW	wykorzystują port o numerze	80)	oraz port źródłowy (przeglądarka wykorzystuje porty	dynamicznie	przydzielane, zwykle o „wysokich” numerach). Komunikat razem z dołączonym	nagłówkiem	TCP	nazywa	się	segmentem	TCP.
    \item Do segmentu TCP zostanie dodany nagłówek I – w ten sposób	powstanie pakiet (datagram) IP.	Nagłówek IP	zawiera	m.in. adres	IP	źródłowy (IP1) i adres P docelowy (IP2).
    \item Pakiet  musi być przesłany w ramce. Do pakietu musi zostać dodany nagłówek ramki, zawierający	źródłowy adres MAC (MAC1 – komputer	1 tworzący ramkę zna swój adres	MAC)	 oraz docelowy adres	MAC (powinien to być MAC2). \textbf{Komputer 1 nie zna adresu MAC komputera 2}. Zna	 tylko jego	 adres IP. W IPv4 do poznania adresu docelowego MAC wykorzystywany jest \textbf{protokół ARP} – Address	 Resolution	 Protocol.
    \begin{itemize}
        \item Komputer 1 wysyła specjalną ramkę	\textbf{ARP Request} (zapytanie	ARP, ramka ta NIE zawiera w	pakietu	IP), która ma adres	docelowy składający	się	z samych jedynek (48	jedynek: ffff-ff-ff-ff-ff).	Adres	ten	nazywa	się	\textbf{adresem	rozgłoszeniowym}. Ramka ARP Request jest przesyłana przez przełącznik do wszystkich przyłączonych komputerów. Ramka ta zawiera zapytanie o adres MAC	komputera,	którego adres IP jest przesyłany w ramce.
        \item Każdy	komputer przyłączony do	przełącznika ma	obowiązek odebrać ramkę	wysłaną na	adres rozgłoszeniowy MAC. Jednak tylko komputer o zadanym IP odpowie na ARP Request.
        \item Odpowiedź to	specjalna ramka \textbf{ARP	Reply}	(odpowiedź	ARP).	Odpowiedź	ARP	jest wysyłana na adres MAC komputera 1.
    \end{itemize}
    \item Po tym, jak komputer 1 pozna adres MAC komputera 2, może już zbudować ramkę przeznaczoną do komputera 2. Ramka ta zawiera wcześniej zbudowany pakiet IP (który z
    kolei zawiera segment TCP, który z kolei zawiera komunikat HTTP). Ramka	jest wysyłana do przełącznika, a przełącznik dostarcza ją tylko	do komputera 2.
    \begin{itemize}
        \item Przełącznik uczy się adresów MAC przyłączonych komputerów i routerów i zapamiętuje w tablicy przypisanie adresu MAC do konkretnego swojego portu. Jeśli przełącznik dostanie ramkę ze znanym mu	 adresem MAC, to kieruje tę ramkę tylko do odpowiedniego portu, w przeciwnym wypadku wysyła kopię ramki do wszystkich swoich portów (z	wyjątkiem tego, na którym	dostał ramkę).
    \end{itemize}
    \item Komputer 2 (jego karta sieciowa) odbiera ramkę, sprawdza adres MAC docelowy i sumę kontrolną, po czym „wyjmuje” z ramki pakiet IP. Sprawdza adres docelowy IP i „wyjmuje”	z pakietu segment TCP. Sprawdza do którego portu należy przekazać zawartość (komunikat HTTP) i ostatecznie „wyjmuje” komunikat http z segmentu i przekazuje do portu 80, na którym nasłuchuje serwer WWW.
    \item Serwer WWW skonstruuje odpowiedź – stronę WWW zapisaną z wykorzystaniem języka HTML). Strona ta zostanie umieszczona w komunikacie http, który następnie musi być przesłany do komputera 1. Mechanizm jest analogiczny jak poprzednio.
\end{itemize}
W rzeczywistości zanim może zostać przesłany segment TCP, komputery wykorzystujące ten protokół do komunikacji, muszą zbudować tzw. połączenie TCP.


\begin{tabular}{|c|c|c|c|c|}
\hline
Nagłówek ramki & Nagłówek IP & Nagłówek TCP & Komunikat HTTP & Suma kontrolna\\
(numery MAC) & (numery IP) & (numery portów) & & \\
& 20 bajtów & 20 bajtów & & 4 bajty\\
\hline
\end{tabular}

\textbf{W przypadku komunikacji między komputerami rozdzielonymi przynajmniej jednym routerem}
\begin{itemize}
    \item Wszystko do skonstruowania pakietu IP włącznie działa tak samo. Komputer tworzący ramkę musi więc wykorzystując ARP Request poznać
    MAC adres routera, czyli swojej \textbf{bramy domyślnej} (default gateway). Stąd elementem konfiguracji komputera jest podanie mu nie tylko
    jego adresu IP, ale również adresu IP bramy.
    \item Ramka jest wysyłana do routera.
    \item Router (brama) po otrzymaniu ramki „wyjmuje” z niej pakiet IP, zagląda do nagłówka i sprawdza jaki jest adres docelowy IP. Na podstawie
    tego adresu i tablicy routowania wyznacza router następnego skoku i konstruuje i wysyła do niego nową ramkę, w której umieszcza przesyłany pakiet IP. Analogicznie aż pakiet dotrze w kolejnych ramkach do docelowej sieci i do docelowego komputera.
\end{itemize}

\subsection{Model ISO/OSI}
OSI (Open Systems Interconnection) utworzony przez Międzynarodową Organizację
Normalizacyjną (ISO International Organization for Standarization w Genewie)
stanowi \textbf{model referencyjny} (wzorcowy).

\begin{itemize}
    \item ułatwienie zrozumienia procesów zachodzących podczas komunikowania się komputerów
    \item ułatwienie projektowania protokołów komunikacyjnych
\end{itemize}

\begin{tabular}{|c|c|}
\hline
\textbf{Numer warstwy} & \textbf{Nazwa warstwy}\\
\hline
7 & Aplikacji\\
\hline
6 & Prezentacji\\
\hline
5 & Sesji\\
\hline
4 & Transportu\\
\hline
3 & Sieci\\
\hline
2 & Łącza danych\\
\hline
1 & Fizyczna\\
\hline
\end{tabular}

Każdą z warstw można rozpatrywać w aspekcie dwóch zasadniczych funkcji: odbierania i
nadawania.
\begin{itemize}
\item \textbf{Warstwa fizyczna} - standard połączenia fizycznego, charakterystyki wydajnościowe nośników. Same media transmisyjne pozostają poza dziedziną jej
zainteresowania (czasem określane są terminem warstwa zerowa).
\item \textbf{Warstwa łącza danych} – grupowanie danych wejściowych (z warstwy fizycznej) w bloki zwane \textbf{ramkami} danych („jednostki
danych usług warstwy fizycznej”), mechanizmy kontroli poprawności
transmisji (FCS).
\item \textbf{Warstwa sieci} - określenie trasy przesyłania
danych między komputerami poza lokalnym segmentem sieci LAN, protokoły trasowane takie jak IP (ze stosu protokołów TCP/IP), IPX
(Novell IPX/SPX), DDP (AppleTalk) (adresowanie logiczne).
\item \textbf{Warstwa transportu} - kontrola błędów i przepływu danych
poza lokalnymi segmentami LAN, protokoły zapewniające
komunikację procesów uruchomionych na odległych komputerach (np. oprogramowanie klient/serwer), w tym komunikację z zapewnieniem
niezawodności dostarczania danych. Protokoły tej warstwy to np. TCP oraz UDP (z
TCP/IP), SPX (Novell IPX/SPX), ATP, NBP, AEP (AppleTalk).
\item \textbf{Warstwa sesji} - zarządzanie przebiegiem komunikacji podczas
połączenia między komputerami (sesji).
\item \textbf{Warstwa prezentacji} - kompresja, kodowanie i
translacja między niezgodnymi schematami kodowania oraz szyfrowanie.
\item \textbf{Warstwa aplikacji} - interfejs między aplikacjami a
usługami sieci.
\end{itemize}

Określona sesja komunikacyjna nie musi wykorzystywać protokołów ze wszystkich warstw
modelu. Przy nadawaniu dane kierowane są od warstwy 7 do 1, przy odbiorze od 1 do 7.

Używane są też inne modele warstwowe, np. jeden z takich
prostszych modeli – model TCP/IP – jest często wykorzystywany przy opisie zestawu (stosu)
protokołów TCP/IP (Internet). Nie ma warstwy prezentacji ani warstwy sesji, ponieważ zestaw TCP/IP nie zawiera
żadnych protokołów, które można byłoby przypisać do tych warstw. Nieco inny model
„dydaktyczny” został zaproponowany przez Tannenbauma.

\begin{tabular}{|c|c|c|c| }
\hline
Nr warstwy OSI & Nazwa warstwy OSI & Nazwa warstwy TCP/IP & Nazwa warstwy Tannenbaum\\
\hline
7 & Aplikacji & Aplikacji & Aplikacji\\
6 & Prezentacji & & \\
5 & Sesji & & \\
4 & Transportu & Transportu & Transportu\\
3 & Sieci & Intersieci & Sieci\\
2 & Łącza danych & Interfejsu sieciowego & Łącza danych\\
1 & Fizyczna & & Fizyczna\\
\hline
\end{tabular}

\subsection{Zestaw (stos) protokołów TCP/IP}
Składa się z protokołów, które stanowią obecnie podstawę działania Internetu. TCP/IP jest standardem w komunikacji sieciowej.

\begin{tabular}{|c|c|}
    \hline
    Warstwa TCP/IP & Warstwa modelu OSI\\
    \hline
    Aplikacji & Aplikacji\\
    & Prezentacji\\
    & Sesji\\
    \hline
    Transportu & Transportu\\
    \hline
    Internetowa (sieci, intersieci) & Sieci\\
    \hline
    Dostępu do sieci (interfejsu
    sieciowego) & Łącza danych\\
    & Fizyczna\\
    \hline
\end{tabular}

Protokoły z zestawu TCP/IP:
\begin{itemize}
    \item TCP - warstwa transportu,
    \item UDP - warstwa transpotu,
    \item IP - IPv4 i IPv6, warstwa internetowa,
    \item ARP - tłumaczy adresy między warstwą internetową a warstwą interfejsu
    sieciowego, czasami zaliczany do tej ostatniej warstwy,
    \item ICMP - m.in. komunikaty o problemach,
    \item IGMP - komunikacja grupowa.
\end{itemize}

Na warstwę aplikacji składają się komponenty programowe sieci, wysyłające i odbierające
informacje przez tzw. porty TCP lub UDP (z warstwy transportu).
Protokoły warstwy aplikacji to między innymi:
\begin{itemize}
    \item FTP (File Transfer Protocol),
    \item TELNET,
    \item DNS (Domain Name System) związany z usługą DNS (Domain Name Service).
\end{itemize}


Dane przechodząc w dół stosu protokołów TCP/IP są opakowywane i otrzymują
odpowiedni nagłówek. Porcje danych przesyłane w dół stosu mają różne
nazwy:
\begin{itemize}
    \item \textbf{Komunikat} - porcja danych utworzona w warstwie aplikacji i przesłana do warstwy transportu.
    \item \textbf{Segment} - porcja danych utworzona przez oprogramowanie implementujące protokół TCP w warstwie transportu. Zawiera w sobie komunikat.
    \item \textbf{Datagram UDP} - porcja danych utworzona przez oprogramowanie implementujące protokół UDP w warstwie transportu.
    \item \textbf{Datagram} - również porcja danych utworzona w warstwie internetowej przez oprogramowanie implementujące protokół IP. Datagram IP zawiera w sobie segment, bywa nazywany pakietem.
    \item \textbf{Ramka} - porcja danych utworzona na poziomie dostępu do sieci.
\end{itemize}

Sekwencja zdarzeń przy wysłaniu danych:
\begin{itemize}
    \item Aplikacja przesyła dane do warstwy transportu.
    \item Dalszy dostęp do sieci realizowany jest przez TCP albo UDP.
    \begin{itemize}
        \item TCP realizuje tzw. niezawodne połączenia i kontroluje przepływ danych zapewniając niezawodne dostarczenie danych.
        \item UDP nie zapewnia niezawodności, ale jest szybszy.
    \end{itemize}
    \item Segment lub datagram UDP przesyłany jest do warstwy IP, gdzie protokół IP dołącza między innymi informacje o adresach IP źródła i celu tworząc datagram IP (pakiet).
    \item Datagram z IP przechodzi do warstwy interfejsu sieciowego, gdzie tworzone są ramki. W sieci LAN ramki zawierają adres fizyczny (przypisany do karty sieciowej) otrzymany zprotokołu ARP.
    \item Ramka przekształcana jest w ciąg sygnałów, który zostaje przesłany przez sieć.
\end{itemize}

\textbf{RFC} (Request for Comments) - miejsce publikowania oficjalnych standardów internetowych. Niektóre dokumenty RFC nie są standardami, ale pełnią funkcję informacyjną. Każdy dokument RFC posiada swój numer – większe numery oznaczają nowsze dokumenty.

\subsubsection{ARP (Address Resolution Protocol)}
ARP stosowany jest w sieciach Ethernet (jeśli w warstwie sieci wykorzystywany jest protokół
IPv4), był też używany w sieciach Token Ring. W wersji IPv6 protokół ARP nie jest w ogóle wykorzystywany, zastępują go inne mechanizmy.\\

\begin{itemize}
    \item  Zadaniem ARP jest \textbf{odnalezienie adresu fizycznego MAC} na podstawie znanego wprost adresu IP (został wpisany przez użytkownika, lub uzyskany automatycznie na podstawie nazwy domenowej (www) dzięki DNS).
    \item Ze względu na możliwość wymiany karty sieciowej w komputerze o określonym adresie IP ARP musi być \textbf{dynamiczny}.
    \item ARP jest oparty na \textbf{metodzie rozgłoszeniowej} i zasadzie \textbf{żądania i odpowiedzi}.
    \item ARP najpierw sprawdza w swojej pamięci podręcznej (\textbf{cache}) czy posiada wpis dla danego IP. Jeśli nie, to zostaje wysłana ramka rozgłoszeniowa \textbf{ARP Request} Message w fizyczneym segmencie sieci, do którego przyłączony jest nadawca (ARP requestor).
    \begin{itemize}
        \item Jeśli węzeł docelowy znajduje się w tym samym segmencie sieci lokalnej, ARP requestor pyta wprost o to kto ma docelowy adres IP. ARP responder odpowiada wysyłając ramkę ARP Reply pod adres MAC, z którego przyszło żądanie. Po wymianie ramek zarówno nadawca jak i odbiorca mają uaktualnione tablice w pamięci podręcznej (cache).
        \item Jeśli węzeł docelowy znajduje się w innym segmencie sieci datagram jest kierowany do domyślnego routera (IP wpisane w konfiguracji TCP/IP lub wykorzystanie Proxy ARP. ARP requester pyta o adres IP routera domyślnego, router odpowiada wysyłając ramkę ARP respond i podaje swój adres MAC.
    \end{itemize}
    \item Po otrzymaniu ARP Request uaktualniane są również pamięci podręczne cache ARP w
    komputerach, które miały w pamięci podręcznej IP ARP requestor. Otrzymanie ramki ARP request jest zatem metodą aktualizacji wpisów w
    pamięci podręcznej ARP.
    \item Wpisy w pamięci podręcznej ARP są usuwane po okresie nieużywania rzędu kilku minut. W
    przypadku użycia wpisu czas ten może wzrosnąć, z pewnym limitem górnym.
    \item TCP/IP w Microsoft Windows pozwala na użycie statycznych wpisów w pamięci podręcznej
    ARP. Jednak są one przechowywane w RAM, więc wyłączaniu komputera przepadają.
    \item Struktura ramki ARP:
    \begin{itemize}
        \item Typ sprzętu (2 oktety)
        \item Typ protokołu (2 oktety)
        \item Długość adresu sprzętu (1 oktet)
        \item Długość adresu protokołu (1 oktet)
        \item Kod operacji (2 oktety)
        \item Adres sprzętu nadawcy (dla Ethernet 6 oktetów)
        \item Adres protokołu nadawcy (dla IPv4 4 oktety)
\end{itemize}
\end{itemize}

\subsubsection{Wykrywanie zduplikowanych adresów IP}
Tzw "zbędny ARP"
\begin{itemize}
    \item Węzeł wysyła ARP Request z zapytaniem o swój własny adres.
    \begin{itemize}
        \item Jeśli ARP Reply nie nadejdzie to znaczy, że w lokalnym segmencie nie ma konfliktu adresów.
        \item Jeśli odpowiedź nadejdzie, oznacza to konflikt.
    \end{itemize}
    \item Węzeł już skonfigurowany traktowany jest jako węzeł z poprawnym adresem (\textbf{węzeł zgodny}, defending node), węzeł
    wysyłający „zbędny ARP” jest \textbf{węzłem konfliktowym} (offending node).
    \item \textbf{Węzeł konfliktowy wprowadza błąd} w pamięci podręcznej ARP komputerów w \textbf{całym segmencie} sieci. ARP Reply z węzła zgodnego nie naprawia sytuacji (ramka ARP Reply nie jest ramką rozgłoszeniową), więc zgodny wysyła ARP Request ze swoim adresem po wykryciu konfliktu.
\end{itemize}
Datagramy IP wysłane na w ramkach z niepoprawnym adresem MAC odbiorcy
przepadają. Protokół IP nie zapewnia niezawodnej dostawy datagramów i nie
spowoduje powtórnego przesłania datagramu w nowej ramce. Za niezawodność
odpowiedzialne są protokoły warstwy transportu.

\subsubsection{Proxy ARP}
Router ze skonfigurowanym mechanizmem Proxy ARP odpowiada na ramki ARP Request w
imieniu wszystkich węzłów – komputerów spoza segmentu sieci lokalnej. Może
być używany jest np. w sytuacji, gdy komputery w sieci nie mają ustawionego domyślnego
routera (domyślna brama, default gateway). Routery mogą mieć włączoną standardowo
opcję Proxy ARP, wówczas jeśli jakiś komputer wyśle ARP Request z adresem spoza danej
sieci lokalnej (zwykle to nie następuje), to router odpowie „w imieniu” komputera
zewnętrznego.


\section{Adresacja IPv4}
Adres IP jest przypisywany do karty sieciowej, nie do komputera.

Są \textbf{trzy typy adresów IPv4}:
\begin{itemize}
    \item \textbf{Adresy jednostkowe} (unicast) – pojedynczy interfejs sieciowy (komunikacja one-to-one).
    \item \textbf{Adresy rozgłoszeniowe} (broadcast) – wszystkie węzły w tym samym segmencie sieci (one-to-everyone).
    \item \textbf{Adresy grupowe} (multicast) – jeden lub wiele komputerów w jednej lub w różnych segmentach sieci (one-to-many).
\end{itemize}

W \textbf{adresie IP} zapisanym binarnie można wyróżnić \textbf{dwie części}:
\begin{itemize}
    \item \textbf{Identyfikator sieci} (Network ID) - pewna liczba bitów z lewej strony adresu
    \item \textbf{Identyfikator hosta} (Host ID) - pozostałe bity.
\end{itemize}
Terminem host określa się komputer, który jest końcowym konsumentem usług sieciowych.

\textbf{Granica} między identyfikatorem sieci a identyfikatorem hosta może być wyznaczona przez
tzw. \textbf{maskę sieci}.

\textbf{Identyfikator sieci}
\begin{itemize}
    \item \textbf{nie} może się składać z \textbf{samych jedynek}.
    \item \textbf{nie} może się składać z \textbf{samych zer}.
    \item \textbf{nie może się powtarzać} w złożonej sieci.
    \item W \textbf{pierwszym oktecie} adresu \textbf{nie} może się znaleźć wartość \textbf{127} (jest ona zarezerwowana dla adresu tzw. pętli zwrotnej).
\end{itemize}

\textbf{Identyfikator hosta}
\begin{itemize}
    \item \textbf{nie} może się składać z \textbf{samych jedynek}.
    \item \textbf{nie} może się składać z \textbf{samych zer}.
    \item musi być \textbf{unikalny} w segmencie sieci lokalnej.
\end{itemize}

Adres IP, który zawiera \textbf{same zera} w części hosta jest traktowany jako \textbf{adres sieci}.

\textbf{Adres ograniczonego rozgłoszenia - 255.255.255.255 = 11111111 11111111 11111111 11111111} -  adres rozgłoszenia
w danym segmencie sieci ograniczonym routerami.\\
\textbf{Adresy rozgłoszenia do sieci lub podsieci mają jedynki tylko w części hosta}.

\textbf{Adresy nieunikalne}, powtarzalne - przykłady:
\begin{itemize}
    \item adresy rozpoczynające się od liczby 127, które oznaczają zawsze komputer lokalny (zwykle 127.0.0.1).
    \item adresy tzw. transmisji grupowej.
    \item grupy tzw. adresów prywatnych.
\end{itemize}

\subsection{Adresowanie oparte na klasach}

Pierwszy bajt adresu determinuje do jakiej klasy należy sieć.

\begin{tabular}{|c|c|c|c|c|}
\hline
Klasa & Adres sieci & Adresy & Zakres 1-go bajtu & Najstarsze bity\\
\hline
A & w.0.0.0 & 1.0.0.0 - 126.0.0.0 & 1 – 126 & 0\\
\hline
B & w.x.0.0 & 128.0.0.0 - 191.255.0.0 & 128 – 191 & 10\\
\hline
C & w.x.y.0 & 192.0.0.0 - 223.255.255.0 & 192 – 223 & 110\\
\hline
D & nie dotyczy & nie dotyczy & 224 – 239 & 1110\\
\hline
E & nie dotyczy & nie dotyczy & 240 – 255 & 11110\\
\hline
\end{tabular}


\begin{tabular}{|c|c|c|c|c|c|c|}
\hline
Klasa & Ilość sieci & Komp. w sieci & ID sieci & ID hosta & "pierwszy" & "ostatni"\\
\hline
A & 126 & $2^{24}-2$ & 1 bajt & 3 bajty & w.0.0.1 & w.255.255.254\\
\hline
B & $(191-128+1)*256$ & $2^{16}-2 = 65 534$ & 2 bajty & 2 bajty & w.x.0.1 & w.x.255.254\\
\hline
C & $(192-223+1)*256*256$ & $2^8 -2 = 254$ & 3 bajty & 1 bajt & w.x.z.1 & w.x.z.254\\
\hline
\end{tabular}

\begin{itemize}
\item \textbf{Adresy klasy D} - przeznaczone są do transmisji grupowych.
\item \textbf{Adresy klasy E} - zarezerwowane (nie wykorzystywane normalnie do transmisji pakietów).
\item \textbf{Adresy pętli zwrotnej} (loopback) - postaci 127.x.y.z (na ogół 127.0.0.1). Cały ruch przesyłany na ten adres nie wychodzi z komputera.
\end{itemize}

Identyfikator sieci można określić na podstawie adresu IP oraz tzw. \textbf{maski sieci}. Jest to \textbf{liczba binarna 32 bitowa}, zapisywana podobnie jak adres IP, jednak \textbf{maska zawsze z lewej strony ma jedynki, natomiast z prawej ma zera}.\\
Przykłady masek:\\
255.0.0.0 = 11111111.00000000.00000000.00000000 = /8,\\
255.255.0.0 = 11111111. 11111111.00000000.00000000 = /16.\\
\\
Adres sieci = AdresIP \& Maska\\


\textbf{Dzielenie sieci na podsieci}\\
Dzielenie sieci na fragmenty nazywane \textbf{podsieciami} w celu zwiększenia efektywności działania.
\begin{itemize}
    \item zmniejszenie ruchu w segmentach,
    \item zmniejszenoe tzw. dziedziny rozgłaszania (obszary przekazywania ramek rozgłoszeniowych,
    tj. z adresem MAC ff-ff-ff-ff-ff-ff-)
    \item zwiększenie bezpieczeństwa. Routery mogą działać jako filtry pakietów, które
    przepuszczają między sobą tylko pakiety spełniające określone kryteria.
\end{itemize}
Adres podsieci można określić przez użycie niestandardowych masek sieci (\textbf{masek podsieci}).

Dzielenie klasy A - maski 255.255.0.0, 255.255.255.0, dla B - 255.255.255.0.

Routery przechowują w tablicach routowania informacje o znanych im trasach do pewnych sieci. Administrator w trakcie konfiguracji routera wprowadza informacje o sieciach bezpośrednio przyłączonych do routera. Potem, po włączeniu opcji dynamicznego rutowania
routery wymieniają się informacjami o sieciach wg protokołów rutowania i na tej podstawie budują sobie pewien obraz
sieci i potrafią wyznaczać trasy datagramów.

Przykład: komputer A: 162.168.1.100, komputer B: 162.168.2.101\\
Maska 255.255.0.0 - komputery są względem siebie lokalne.\\
Maska 255.255.255.0 - komputery są względem siebie odległe (przedzielone routerem).

\subsection{Adresowanie bezklasowe}
Pytanie: czy nie można podzielić sieci na podsieci
z \textbf{użyciem dowolnej liczby jedynek}? Na przykład, jeśli w sieci klasy B o
adresie 149.159.0.0 /16 zastosowalibyśmy maskę podsieci nie 24 bitową (co daje 254 lub
256 podsieci z możliwością adresowania do 254 komputerów) tylko 22 bitową.
Otrzymalibyśmy 62 lub 64 sieci, z których każda mogłaby mieć 1022 komputery. Do określenia sieci należy podać adres
sieci oraz maskę. Obecnie w Internecie powszechnie jest wykorzystywane adresowanie
bezklasowe.
Przykład adresowania bezklasowego: 145.217.123.7 /20 (maska: 255.255.240.0)


\section{Routing}
\textbf{Routowanie} - proces przesyłania pakietów (datagramów IP) od hosta nadawczego do
odbiorcy na ogół z wykorzystaniem routerów pośredniczących. Każdy host oraz router podejmuje decyzję jak przesłać datagram, podejmowaną na podstawie tzw. tabel routowania oraz pewnych reguł.
\textbf{Routing statyczny} - gdy w routerze tabela routowania jest wypełniona wpisami statycznymi i nie zmienia się.\\
\textbf{Routing dynamiczny} - tabela routowania zmienia się dynamicznie na podstawie protokołów routowania.\\
Protokoły routowalne: \textbf{IPv4}, IPX firmy Novell (należący do stosu IPX/SPX), AppleTalk, IPv6. Routery mogą realizować trasowanie dla pakietów z
protokołów innych niż IPv4.\\
Dla routerów tablica routowania na ogół jest modyfikowana dynamicznie na podstawie \textbf{protokołów routowania}. Określają one w jaki sposób routery mają wymieniać między sobą informacje na temat połączeń między routerami w sieci i jak na podstawie tych informacji mają aktualizować swoje tablice routowania.\\
Protokoły routowania: RIP, RIP2, OSPF, IGRP, EIGRP, BGP.
\textbf{Brama domyślna} to router, do którego kierowany jest datagram, jeśli nie została znaleziona dla niego lepsza trasa w tablicy routowania.\\

Typy bezpośrednich połączeń:
\begin{itemize}
    \item rozgłoszenia - np. Ethernet; działa protokół ARP,
    \item punkt-punkt - np. analogowa linia telefoniczna; technologie sieci rozległych WAN, ARP nie jest wykorzystywany;
    \item wielodostęp nierozgłoszeniowy (NBMA) -  technologie przełączania pakietów WAN Frame Relay, ATM; ARP nie jest wykorzystywany.
\end{itemize}

\subsubsection{Tablica routowania IP}
Zawiera wpisy dotyczące tras do hostów, routerów i sieci. Zwykle w
hostach liczba wpisów jest dużo mniejsza niż w routerach i zawiera informacje o bramie domyślnej.\\

W każdym hoście i routerze dla każdego przesyłanego pakietu IP na podstawie tablicy
routowania wyznaczane są dwie wartości:
\begin{itemize}
    \item interfejs – reprezentacja fizycznego urządzenia, przez które ma być wysłany pakiet,
    \item adres następnego skoku - adres IP następnego routera, do którego ma być skierowany datagram lub adres
docelowy hosta, jeśli jest bezpośrednio dołączony do nadawcy\
\end{itemize}

Tablica routowania zawiera następnujące pola:
\begin{itemize}
    \item \textbf{Przeznaczenie (Destination)}\\
     W koniunkcji (logiczne AND) z polem Maska zawiera informację o zakresach adresów IP, które są dostępne przy użyciu tej trasy. Pole to może zawierać ID
     sieci lub adres IP konkretnego hosta lub routera. W prawidłowym wpisie nie może zawierać jedynek w miejscu, gdzie w Masce sieci są zera.
    \item \textbf{Maska sieci}\\
     Zawiera maskę sieci, może też zawierać same jedynki (255.255.255.255).
     \item \textbf{Adres następnego skoku}\\
     Adres IP, do którego datagram będzie przesłany w następnym kroku, jeśli zostanie wybrana ta trasa. Bez znaczenia dla połączeń punkt-punkt.
     \item \textbf{Interfejs}\\
     Oznaczenie interfejsu, przez który datagram będzie przesłany do miejsca określonego przez adres następnego skoku.
     \item \textbf{Metryka}\\
     Liczba wskazująca na koszt trasy. Im wyższa wartość, tym „gorsza” trasa.
     \item \textbf{Odległość administracyjna}\\
     Liczba przypisywana na podstawie tego, w jaki sposób router poznał trasę do danego miejsca docelowego. „Wygrywa” trasa z najmniejszą liczbą. Trasa domyślna może być oznaczana przez 0.0.0.0 w polu Przeznaczenie i 0.0.0.0 w polu Maska sieci.
\end{itemize}

Proces określania trasy na podstawie tablicy routowania:
\begin{itemize}
    \item Dla każdej trasy w tablicy routowania określa się, czy jest ona \textbf{zgodna z adresem IP} w przesyłanym pakiecie. Trasa domyślna jest traktowana zawsze jako zgodna.
    \item Spośród tras zgodnych wybierana jest ta (lub kilka), dla której w polu \textbf{Maska sieci} jest \textbf{największa liczba jedynek}. Może się zdarzyć, że jedyną trasą zgodną jest trasa domyślna.
    \item Spośród tras, które zostały wybrane w punkcie 2 wybierane są trasy o \textbf{najmniejszej metryce}.
    \item Spośród tras wybranych w punkcie 3 wybierana jest dowolna trasa.
\end{itemize}
Routery potrafią również wykonywać równoważenie obciążeń.

\subsubsection{Komunikaty ICMP o przekierowaniu}
Komunikaty ICMP o przekierowaniu pozwalają hostom TCP/IP na konfigurację tylko jednego
routera – bramy domyślnej nawet w sytuacji, gdy w sieci lokalnej są dwa lub więcej
routerów, które są odpowiedzialne za pewne miejsca docelowe.
Hosty mogą zacząć pracę z jedną domyślną trasą i uczyć się topologii sieci (w szczególności
informacji o routowaniu) poprzez otrzymywanie komunikatów ICMP.\\

Komunikaty ICMP o przekierowaniu powinny być generowane przez routery, ale korzystać z
nich mogą tylko hosty.
Jeśli datagram IP zostanie celowo usuwanięty przez router, to może być wysłany odpowiedni komunikat protokołu ICMP do nadawcy.


\section{Protokół IPv4}
\begin{itemize}
    \item Protokół warstwy trzeciej modelu ISO OSI.
    \item Oprogramowanie implementujące protokół IP jest odpowiedzialne za:
    \begin{itemize}
        \item adresowanie IP,
        \item tworzenie datagramów IP (pakietów)
        \item uczestniczenie w kierowaniu ich w sieci z punktu początkowego do punktu docelowego.
    \end{itemize}
    \item realizuje usługę zawodną. Jeśli komunikacja powinna zawierać mechanizmy niezawodności, to muszą one być dostarczone przez protokoły warstwy wyższej.
    \item Datagram IP składa się z nagłówka (header) i bloku danych (payload).
    \begin{itemize}
        \item \textbf{Nagłówek} dzięki informacjom w nim zawartym umożliwia obsługę routowania, identyfikację bloku danych, określenie rozmiaru nagłówka i datagramu oraz obsługę fragmentacji. W nagłówku mogą się znaleźć również tzw. opcje rozszerzające. Ma zmienną długość (20 do 60 bajtów, co 4 bajty).
        \item \textbf{Blok danych} może mieć długość do 65515 bajtów.
    \end{itemize}
\end{itemize}

\subsection{Nagłówek IPv4}
\begin{itemize}
    \item \textbf{Wersja} (4 bity) (=0100)
    \item \textbf{Długość nagłówka IP} (IHL – Internet Header Length) (4 bity)\\
    Najczęściej nagłówek ma 20 bajtów, a więc 5 bloków (0101 binarnie). Maksymalnie długość nagłówka może wynosić 60 bajtów.
    \item \textbf{Typ usługi}: TOS (Type of Service) lub DS. (Differentiaded Services) (8 bitów)\\
    Zawiera dodatkowe informacje, które mogą być użyte w routingu. Pierwotnie pole TOS było zdefiniowane następująco:
    \begin{itemize}
        \item Bits 0-2: Precedence.
        \item Bit 3: 0 = Normal Delay, 1 = Low Delay.
        \item Bits 4: 0 = Normal Throughput, 1 = High Throughput.
        \item Bits 5: 0 = Normal Relibility, 1 = High Relibility.
        \item Bit 6-7: Reserved for Future Use (0).
    \end{itemize}
    TOS było ustawiane przez hosta nadającego i nie było modyfikowane przez routery, miały być używane do obsługi QoS (Quality of Service). W rzeczywistości jego wykorzystanie było problematyczne.\\
    Zmieniono nazwę pola na DS (Differentiated Services) i sześć najstarszych bitównazwano DSCP. Następnie pozostałe dwa bity przeznaczono na ECN.
    \begin{itemize}
        \item Bits 0-5: DCSP
        \item Bits 6-7: ECN
    \end{itemize}
    ECN jest rozszerzeniem protokołów IP oraz TCP. Umożliwia powiadamianie punktów końcowych IP/TCP o nadchodzącym zatorze bez usuwania pakietów, poprzez ustawienie warość 11 na bitach ECN. Jest opcjonalny.\\
    Standardowo (bez obsługi ECN) zator w sieci TCP/IP przejawia się usuwaniem pakietów.
    Dopuszczalne wartości na bitach ECN:
    \begin{itemize}
        \item 00 – Non ECN-Capable Transport, Non-ECT
        \item 10 – ECN Capable Transport, ECT(0)
        \item 01 – ECN Capable Transport, ECT(1)
        \item 11 – Congestion Encountered, CE.
    \end{itemize}
    Odbiorca pakietu przesyła informację do źródła, wykorzystując odpowiednie flagi nagłówka TCP (ze względu na to, że zatorowi może przeciwdziałać TCP, nie IP). Pierwotne źródło danych redukuje prędkość transmisji zmniejszając rozmiar okna przeciążeniowego. Protokół TCP wspiera ECN przez wykorzystanie specjalnych trzech flag w nagłówku: TCP: Nonce Sum (NS), ECN-Echo (ECE) oraz Congestion Windows Reduced (CWR).
    \item \textbf{Długość całkowita} (16 bitów)\\
    Na podstawie tego pola oraz pola Długość nagłówka można określić wielkość bloku danych oraz początek tego bloku. Całkowita długość podawana jest w bajtach, maksymalna możliwa długość może wynosić 65535.
    \item \textbf{Identyfikator} (16 bitów)\\
    Identyfikator kolejnych datagramów. Wartość jest wpisywana przez host nadający i dla kolejnych datagramów jest zwiększana.
    \item \textbf{Flagi} (3 bity)\\
    3 bity tworzące dwie flagi używane przy fragmentacji datagramów.
    \item \textbf{Przesunięcie fragmentu} (13 bitów)\\
    Używane przy fragmentacji datagramów.
    \item \textbf{Czas życia} (TTL) (8 bitów)\\
    Określa przez ile łączy może przejść (skoków) datagram zanim zostanie odrzucony przez router. Host docelowy nie sprawdza TTL. Jeśli pakiet jest odrzucany to wysyłany jest komunikat ICMP „Time Expired – TTL Expired”.
    \item \textbf{Protokół} (8 bitów)\\
    Określa do jakiego protokołu warstwy wyższej należy przekazać datagram. Przykładowe wartości to 1 – ICMP, 6 – TCP, 17 – UDP.
    \item \textbf{Suma kontrolna nagłówka} (16 bitów)\\
    Liczona jest tylko dla nagłówka. Jest on dzielony na słowa 16-to bitowe. Są one dodawane a wynik negowany. Wynik umieszczany jest w polu sumy kontrolnej. W miejscu docelowym suma kontrolna jest ponownie obliczana. Ponieważ nagłówek w miejscu docelowym zawiera sumę kontrolną, to ponownie wyliczona suma powinna składać się z samych jedynek. Jeśli jest inna to oprogramowanie IP odrzuca odebrany pakiet (brak komunikatu o błędzie). Po przejściu przez router jest modyfikowane pole TTL, zatem suma kontrolna powinna ulec zmianie.
    \item \textbf{Adres IP źródła} (32 bity)
    \item \textbf{Adres IP docelowy} (32 bity)
    \item \textbf{Dodatkowe opcje i wypełnienie} (32 bity + ew. więcej).\\
    Opcje mogą zająć maksymalnie 40 bajtów i mogą zawierać m.in.:
    \begin{itemize}
        \item zapis trasy (RR - Record Route)\\
        \begin{itemize}
            \item kod - typ opcji; 1 bajt, RR=7
            \item length - liczba bajtów opcji; 1 bajt, max=39
            \item ptr – numer bajta wolnego miejsca na wpisanie kolejnego adresu IP; 1 bajt, na początku = 4
            \item adres IP 1 (4 bajty)
            \item $\cdots$
            \item adres IP 9 (4 bajty)
        \end{itemize}
        \item zapis czasu – timestamp
        \begin{itemize}
            \item kod - typ opcji; 1 bajt,  timestamp = 0x44
            \item  length - liczba bajtów opcji; 1 bajt, zwykle 36 lub 40
            \item ptr - numer bajtu wolnego miejsca na kolejny wpis; 1 bajt, na początku = 5
            \item OF - flaga przepełnienia. Jeśli router nie może dopisać swojego czasu, bo nie ma już miejsca, to powiększa OF o jeden; 4 bity, na początku = 0
            \item FL - znacznik: 0 – zapisuj tylko czasy, 1 – zapisuj adres IP i czas, 2 – wysyłający wpisuje adresy IP, router o danym IP wpisuje czas
            \item timestamp 1 (4 bajty)
            \item $\cdots$
            \item timestamp 9 (4 bajty)
        \end{itemize}
        \item routowanie źrodłowe\\
        Normalnie to routery wybierają dynamicznie trasę datagramów. Można jednak określić trasę datagramu w opcjach nagłówka IP.
        \begin{itemize}
            \item  dokładne – wysyłający komputer określa dokładną trasę, jaką musi przejść datagram. Jeśli kolejne routery na tej trasie są przedzielone jakimś innym routerem, to wysyła komunikat ICMP „source route failed” i datagram jest odrzucany.
            \item swobodne – wysyłający określa listę adresów IP, przez jakie musi przejść datagram, ale datagram może przechodzić również przez inne routery.
        \end{itemize}
    \end{itemize}
    Pole opcji zawsze zajmuje wielokrotność 4 bajtów, stąd czasem jest uzupełniane zerami.
\end{itemize}
Za nagłówkiem IP w datagramie znajdują się dane (segment TCP, datagram UDP, komunikat ICMP).

\subsection{Fragmentacja datagramów IPv4}
\textbf{MTU} (Maximum Transmission Unit) to największa porcja danych, jaka może być przesłana w ramce przez pewną sieć (sieci) przy wykorzystaniu konkretnej technologii. Jeśli datagram IP jest większy niż wynika to z MTU dla warstwy łącza, to IP dokonuje fragmentacji. Najmniejsze MTU po drodze przejścia datagramu nazywa się \textbf{ścieżką MTU}. Jeśli nastąpiła fragmentacja, to w miejscu docelowym oprogramowanie warstwy IP składa fragmenty z powrotem w pakiety oryginalnej wielkości.
Fragmenty też mogą być dalej dzielone, stają się samodzielnymi pakietami.\\

Pole identyfikator w nagłówku IP zawiera numer wysłanego pakietu. Pole powinno być inicjowane przez protokół warstwy wyższej. Warstwa IP zwiększa identyfikator
o 1 dla kolejnych pakietów.\\
Pole flagi (3 bity) :
\begin{itemize}
    \item Bit 0: zarezerwowane, musi być zero
    \item Bit 1: (DF) 0 = May Fragment, 1 = Don't Fragment.
    \item Bit 2: (MF) 0 = Last Fragment, 1 = More Fragments.
\end{itemize}
Jeśli bit 1 jest ustawiony, to znaczy, że pakiet nie może być dzielony. W przypadku konieczności dzielenia jest odrzucany i do nadawcy wysyłany jest
komunikat ICMP (typ 3 z polem kod = 4).
Pole przesunięcie fragmentu zawiera informację o przesunięciu fragmentu względem początku oryginalnego pakietu. Wyrażane jest w blokach ośmiobajtowych.
Jeśli zgubiony zostanie chociaż jeden fragment, wówczas cały wyjściowy pakiet jest odrzucony, więc fragmentacja jest niekorzystna.
Do tego może ona bardzo obciążać routery.

\subsection{ICMP (Internet Control Message Protocol)}\
\begin{itemize}
    \item raportowanie routingu,
    \item dostarczanie informacji o błędach podczas przesyłania ze źródła do komputera docelowego,
    \item dostarczanie funkcji sprawdzających możliwość komunikacji komputerów wykorzystaniem protokołu IP,
    \item pomoc w automatycznej konfiguracji hostów.
\end{itemize}
Komunikaty ICMP wysyłane są w pakietach IP. W efekcie w ramce znajduje się nagłówek IP, nagłówek ICMP oraz dane komunikatu ICMP.\\

Struktura komunikatu ICMP
\begin{itemize}
    \item Typ (1 oktet)
    \item Kod (1 oktet)
    \item Suma kontrolna (2 oktety)
    \item Dane charakterystyczne dla typu (różna długość)
\end{itemize}

Typy komunikatów ICMP
\begin{tabular}{|c|c|}
    \hline
    0 & Odpowiedź echa (echo reply)\\
    \hline
    3 & Miejsce docelowe nieosiągalne (destination unreachable)\\
    \hline
    4 & Tłumienie źródła (source quench)\\
    \hline
    5 & Przekierowanie (redirect)\\
    \hline
    8 & Żądanie echa (echo request)\\
    \hline
    9 & Ogłoszenie routera (router advertisement)\\
    \hline
    10 & Wybór routera (router selection)\\
    \hline
    11 & Przekroczenie czasu (time exceeded)\\
    \hline
    12 & Problem parametru (parameter problem)\\
    \hline
\end{tabular}

\textbf{Żądanie i odpowiedź echa}
Cel – wysłanie prostego komunikatu do węzła IP i odebranie echa tego komunikatu. Bardzo
użyteczne przy usuwaniu problemów i naprawianiu sieci. Narzędzia takie jak ping oraz tracert i traceroute używają tych komunikatów ICMP do
uzyskania informacji o dostępności węzła docelowego.\\

Żądanie echa:
\begin{itemize}
    \item Typ = 8
    \item Kod = 0
    \item Suma kontrolna (2 oktety)
    \item Identyfikator (2 oktety)
    \item Numer sekwencji (2 oktety)
    \item Opcjonalne dane (różna długość)
\end{itemize}

Odpowiedź echa:
\begin{itemize}
    \item Typ = 0
    \item Kod = 0
    \item Suma kontrolna (2 oktety)
    \item Identyfikator, Numer sekwencji, Opcjonalne dane przepisane z Echo request.
\end{itemize}

\section{Routing dynamiczny}
Sposób obsługi routowania przez warstwę IP to \textbf{mechanizm routowania} -
przeglądanie przez tablicy routowania, podejmowanie decyzji co do przesyłania datagramów IP.
Przez pojęcie \textbf{polityka routowania} określa się działania procesu routowania podejmowane w
celu ustanowienia i bieżącej modyfikacji tablicy routowania, jest ona realizowana z wykorzystaniem protokołów routowania.\\

Pożądane cechy protokołów routowania to:
\begin{itemize}
    \item Wyznaczenie \textbf{najlepszej trasy} do punktu docelowego, wymaga określenia kryterium porównywania tras.
    \item \textbf{Odporność} (robustness) - protokoły muszą zawsze działać poprawnie.
    \item \textbf{Szybkie osiągnięcie zbieżności} (rapid convergence), czyli stanu, w którym wszystkie routery „widzą” jednakowo topologię sieci.
Szybkość określa czas rozpowszechnienia informacji o zmianach.
    \item \textbf{Dopasowanie do zmian} (flexibility), wyznaczanie nowych optymalnych tras.
\end{itemize}

Internet jest zorganizowany jako grupa tzw. systemów autonomicznych (Autonomous
System – AS), z których każdy jest osobno administrowany. W każdym są wewnętrzne protokoły routowania (ang. IGP – interdomain gateway protocol lub IRP – interdomain routing protocol).\\

Ze względu na sposób działania protokoły routowania wewnętrznego dzielimy na:
\begin{itemize}
    \item protokoły \textbf{wektora odległości} (DV, distance-vector): RIP, RIP2, IGRP, EIGRP
    \item protokoły \textbf{stanu łącza} (link-state): OSPF, OSPF2, IS-IS, NLSP
\end{itemize}
Uwaga: w starszych opracowaniach firmy Cisco protokół EIGRP był określany jako protokół
hybrydowy.

\textbf{Zewnętrzne protokoły routowania} (EGP -bexterior gateway protocols) - międzydomenowe protokoły routowania używane między routerami działającymi w różnych systemach autonomicznych.
Najważniejszym protokołem zewnętrznym jest BGP.
Oprócz protokołów routowania rozważa się protokoły routowalne, takie jak IP, IPX, Apple
Talk. Określają sposoby adresowania, umożliwiające dostarczanie
pakietów w złożonej sieci komputerowej. Routery mogą wyznaczać trasy dla różnych
protokołów routowalnych, nie tylko IP. Każdy z protokołów routowania i każdy z protokołów
routowalnych musi być w routerze skonfigurowany.

\subsection{Protokoły routowania wektora odległości}
Distance vector – wektor odległości. Protokoły wektora odległości są oparte na \textbf{algorytmie Bellmana Forda} obliczania najkrótszych ścieżek w grafie.\\
Węzły grafu oznaczają routery, krawędzie odpowiadają połączeniom między routerami.
Połączenia te mają różne koszty, co odpowiada różnym wagom krawędzi grafu.
W protokołach routowania wagi nie mogą być ujemne, co oznacza, że można też
wykorzystać np. algorytm Dijkstry (jest wykorzystywany w protokołach stanu łącza).\\

Nie zawsze router jest w stanie wykryć uszkodzenie łącza. Uszkodzeniu
może ulec też np. sąsiedni router albo ramka zawierająca pakiet z wektorem odległości i wektor
odległości nie dotrze do docelowego routera. Dlatego w protokołach typu wektor odległości
trasa jest zaznaczana jako niedostępna, gdy router nie dostanie o niej informacji od sąsiada
przez kilka kolejnych rozgłoszeń (np. w RIP 180 sekund, czyli sześć
rozgłoszeń). Trasa niedostępna nie jest jeszcze usuwana z tablicy routowania przez
kilka rozgłoszeń, np. w RIP przez 90 sekund. Powoduje to większe opóźnienie w czasie uzyskania zbieżności.\\

\subsection{Niekorzystne zjawiska związane z routowaniem wg protokołów wektora odległości}
\begin{itemize}
    \item Pętle routowania.
    \item Efekt odbijania.
    \item Zliczanie do nieskończoności.
\end{itemize}

Taktyki rozwiązania:
\begin{itemize}
    \item \textbf{Dzielony horyzont (split horizon)}
    \begin{itemize}
        \item \textbf{Do łącza nie zostanie przekazana informacja o trasach wiodących przez to łącze}.
        \item Dzielony horyzont nie zawsze, ale zazwyczaj likwiduje \textbf{pętle routowania}.
    \end{itemize}

    \item \textbf{Natychmiastowe/wymuszane aktualizacje (triggered updates)}
    \begin{itemize}
        \item W przypadku zmiany metryki trasy \textbf{musi nastąpić rozgłoszenie bez względu na okres
    rozgłoszeń} charakterystyczny dla danego protokołu.
        \item Powoduje to \textbf{szybszą zbieżność} i częściowo zapobiega \textbf{pętlom routowania}.
    \end{itemize}

    \item \textbf{Zegary hold-down (hold-down timers)}
    \begin{itemize}
        \item Router po otrzymaniu od sąsiada informacji o dezaktualizacji trasy włącza \textbf{specjalny zegar} (hold-down timer).
        \item Jeśli przed upływem czasu progowego nastąpi:
        \begin{itemize}
            \item \textbf{aktualizacja od tego samego sąsiada} na trasę aktywną, to \textbf{trasa} jest zaznaczana jako \textbf{aktywna}.
            \item router dostanie \textbf{od innego routera informację} o trasie do rozważanego miejsca docelowego z \textbf{metryką mniejszą bądź równą} tej zdezaktualizowanej, wówczas następuje \textbf{wpis zgłoszonej trasy}.
            \item router dostanie \textbf{od innego routera informację} o trasie do rozważanego miejsca docelowego z \textbf{metryką większą} od tej zdezaktualizowanej, taka trasa \textbf{nie jest brana pod uwagę}.
        \end{itemize}
    \end{itemize}
\end{itemize}

\subsection{Protokół RIP}
\begin{itemize}
    \item Protokół typu wektor odległości.

    \item Metryką w RIP jest liczba skoków (hops) do celu. Można skonfigurować inne wartości dla połączeń, więc np. preferencję tras szybszych.

    \item Metryka 16 oznacza umownie nieskończoność (miejsce niedostępne), zatem RIP nie jest dobrym protokołem w przypadku dużych sieci.

    \item Można ustawić trasę domyślną (adres 0.0.0.0).

    \item W wersji RIP na routerach Cisco można przechowywać więcej niż jedną trasę o
    takiej samej metryce. Można włączyć równoważenie obciążeń (load balancing) na dwa
    sposoby:
    \begin{itemize}
        \item \textbf{Process switching} (packet-by-packet load balancing), kosztowny i dlatego nie polecany, każdy pakiet jest kierowany osobno, dla każdego jest przeglądana tablica routowania.
        \item \textbf{Fast switching} (destination-by-destination), tylko dla pierwszego pakietu z pewnego miejsca źródłowego do pewnego miejsca docelowego przeszukiwana jest tablica routowania. Wyznaczona trasa jest zapisywana w pamięci podręcznej (cache) i kolejne pakiety wędrują tą samą ścieżką.
    \end{itemize}

    \item Wykorzystywane są następujące \textbf{mechanizmy} typowe dla protokołów wektor odległości:
    \begin{itemize}
        \item Split horizon (+ with poison reverse)
        \item Holddown counters (timers)
        \item Triggered updates
    \end{itemize}

    \item \textbf{Cztery zegary, liczniki} (timers, counters):
    \begin{itemize}
        \item \textbf{Update timer} (standardowo 30 sekund) – po przesłaniu wektora odległości
        (routing update) zegar jest zerowany. Po osiągnięciu 30 s. wysyłany jest następny wektor.
        \item \textbf{Invalid timer} (standardowo 180 sekund) – za każdym razem jak router dostaje uaktualnienie pewnej trasy zegar ten dla trasy jest zerowany. Po osiągnięciu wartości progowej trasa jest zaznaczana jako niepoprawna, ale pakiety jeszcze są kierowane tą trasą.
        \item \textbf{Hold-down timer} (standardowo 180s.) – po przekroczeniu wartości progowej
        przez invalid timer trasa jest ustawiana w stan hold-down. Trasa jest ustawiana w stan holddown również gdy router dostanie informację o tym, że sieć jest nieosiągalna (i nie ma innej, osiągalnej trasy).
        \item \textbf{Flush-timer} (standardowo 240s.) – zegar dla trasy jest zerowany po otrzymaniu informacji o trasie. Po osiągnięciu czasu progowego trasa jest usuwana nawet, jeśli trasa jest jeszcze w stanie hold-down.
    \end{itemize}

    \item Przewidziano możliwość \textbf{odpytywania routera o cały wektor odległości} lub o \textbf{trasy} do pewnych miejsc docelowych – takie możliwości są wykorzystywane prze starcie oraz na ogół w celach diagnostycznych.\\

    \item \textbf{Zalety RIP}
    \begin{itemize}
        \item prostota - procesor nie jest nadmiernie obciążony aktualizacją tablicy routowania i innymi działaniami,
        \item łatwość konfiguracji.
    \end{itemize}

    \item \textbf{Wady RIP}
    \begin{itemize}
        \item wolne rozprzestrzenianie się informacji o zmianach w topologii sieci (wolna zbieżność),
        \item stosunkowo częste (co 30s.) przesyłanie dużych porcji informacji w komunikatach RIP, co obciąża sieć.
        \item Wadą RIPv1 jest to, że nie daje możliwości przesyłania masek. RIP w wersji 1 jest protokołem routowania klasowego. Przyjmowana jest maska taka, jaka jest ustawiona na interfejsie, do którego dotarł wektor odległości z tą informacją. Na granicach klas jednak routery RIP wykonują automatyczną sumaryzację, co przy niepoprawnych konfiguracjach może prowadzić do błędów w routowaniu.
    \end{itemize}

    \item RIPv2 przekazuje maski podsieci, można stosować sieci bezklasowe i podsieci o zmiennym rozmiarze. Umożliwia prostą autentykację (przez hasła). Przekazuje adresy następnego skoku w komunikatach. Część wad RIP pozostała: 16 jako metryka oznaczająca nieskończoność, brak alternatywnych tras.
\end{itemize}

\subsection{Wiele protokołów routowania. Odległości administracyjne.}
W środowisku współdziałania wielu protokołów routowania dla tras, w zależności od tego
jakie jest ich źródło, ustawiana jest tzw. \textbf{odległość administracyjna}. Odległość jest używana tylko \textbf{wewnętrznie przez router}, wybierane są trasy o \textbf{najmniejszej odległości}.\\

Standardowe odległości dla tras:\\
\begin{tabular}{|c|c|}
    \hline
    Źródło trasy & Odległość administracyjna\\
    \hline
    Connected interface & 0\\
    \hline
    Static route & 1\\
    \hline
    Summary EIGRP & 5\\
    \hline
    External BGP & 20\\
    \hline
    Internal EIGRP & 90\\
    \hline
    IGRP & 100\\
    \hline
    OSPF & 110\\
    \hline
    IS-IS & 115\\
    \hline
    RIP & 120\\
    \hline
    EGP & 140\\
    \hline
    Internal BGP & 200\\
    \hline
    Unknown & 255\\
    \hline
\end{tabular}

Na routerach można również włączyć redystrybucję tras między protokołami routowania
według różnych zasad, z odpowiednim przeliczaniem metryk.


\section{Protokoły UDP i TCP (warstwa transportowa)}
\begin{itemize}
    \item Informacje o \textbf{docelowym i źródłowym procesie} zawarte są w nagłówkach protokołów warstwy transportu.
    \item Protokoły UDP i TCP umożliwiają dostarczenie danych do procesu działającego na komputerze, przy czym wykorzystywane są tzw. \textbf{porty}. Porty są ponumerowane, numer portu jest liczbą
    dwubajtową.
    \item Aplikacja rezerwuje na swoje potrzeby pewne zasoby (komunikacyjne bufory w pamięci
    operacyjnej), ma do dyspozycji tzw. \textbf{gniazda}.
    \item Każde gniazdo jest identyfikowane przez numer IP oraz numer portu. \textbf{Interfejs komunikacyjny}  umożliwiający komunikowanie się programów z wykorzystaniem TCP/UDP nazywa się \textbf{interfejsem gniazd}.
\end{itemize}

\subsection{UDP – User Datagram Protocol}
\begin{itemize}
    \item Prosty protokół bezpołączeniowy warstwy transportu.
    \item Umożliwia przesyłanie danych między procesami dzięki określeniu adresów IP komputerów oraz 16 bitowych numerów portów.
    \item Porcja danych zgodna z protokołem UDP nazywana jest datagramem/pakietem UDP.
    \item Nie zapewnia niezawodności. Ewentualne zapewnienie niezawodności musi być realizowane przez protokoły warstwy aplikacji.
    \item Niewielki nagłówek (8 bajtów), nie zawiera mechanizmów ustanawiania połączenia ani sterowania przepływem datagramów, zatem jest szybszy od TCP.
    \item Datagramy UDP mogą być przesyłane w pakietach IP z adresem docelowym przesyłania grupowego.
    \item Przykłady zastosowań: strumieniowanie audio/wideo, wideokonferencje, transmisje głosu; RIP (port 520).
\end{itemize}

Aplikacja jest odpowiedzialna za rozmiar wysyłanego datagramu. Jeśli wielkość przekroczy
MTU sieci, wówczas datagram IP (zawierający w sobie datagram UDP) jest dzielony
(następuje fragmentacja IP).


\subsubsection{Porty}
Aktualne przyporządkowanie numerów portów można znaleźć na stronie IANA.
\begin{itemize}
    \item Poprawne numery portów: $1 \dots 65535$.
    \item Numer 0 może być używany jako numer portu źródłowego, jeśli nadawca nie oczekuje odpowiedzi.
\\
    \item IANA dzieli porty na trzy grupy:
    \begin{itemize}
        \item $1 \dots 1023$ – porty ogólnie znane, mogą być przypisywane przez procesy systemowe lub działające z uprawnieniami użytkownika uprzywilejowanego.
        \item $1024 \dots 49151$ – zarejestrowane, do użytku przez różne aplikacje.
        \item $49152 \dots 65535$ – dynamiczne lub prywatne, np. dla testowanych aplikacji klient-serwer. Mogą być przydzielane dynamicznie np. dla przeglądarki WWW.
\end{itemize}
\end{itemize}

\subsubsection{Enkapsulacja datagramu UDP}

\begin{tabular}{|c|c|c|}
\hline
nagłówek IP & nagłówek UDP & dane UDP\\
20 bajtów & 8 bajtów & $\dots$\\
\hline
\end{tabular}

\textbf{Nagłówek UDP}
\begin{itemize}
    \item Numer portu źródłowego (16 bitów)
    \item Numer portu docelowego (16 bitów)
    \item Długość UDP (nagłówek + dane) – wypełniana opcjonalnie (16 bitów)
    \item Suma kontrolna UDP (16 bitów)
    \item Dane, jeśli są
\end{itemize}

\textbf{Suma kontrolna}\\
\begin{itemize}
    \item Jedyny mechanizm sprawdzenia poprawności datagramu w UDP.
    \item Opcjonalna, jeśli datagram UDP jest przesyłany w pakiecie IPv4.
    \item Obowiązkowa, jeśli datagram UDP jest przesyłany w pakiecie IPv6.
    \item Dodawane są liczby 16 bitowe, stąd możliwa konieczność dodania do obliczeń
dodatkowego bajtu z samymi zerami (jeśli długość datagramu liczona w bajtach jest liczbą
nieparzystą).
    \item Do obliczenia sumy kontrolnej używany jest tzw. pseudonagłówek. Pseudonagłówek nie jest przesyłany.
\end{itemize}

\textbf{Pseudonagłówek} (12 bajtów) w pakiecie IPv4:
\begin{itemize}
    \item Adres IP źródła (32 bity)
    \item Adres IP celu (32 bity)
    \item 8 zer
    \item Typ protokołu (8 bitów, UDP = 17)
    \item Długość UDP (16 bitów)
\end{itemize}
Algorytm jest taki sam jak dla sumy kontrolnej nagłówka IPv4 (jednak w IPv4 suma kontrolna
obejmowała sam nagłówek, w UDP obejmuje również przesyłane za nagłówkiem dane).

\subsection{TCP – Transmission Control Protocol}
Oprogramowanie TCP tworzy połączenia między dwoma procesami z
jednoczesną dwukierunkową transmisją. Punkty końcowe są identyfikowane przez parę: numer IP, numer
portu. Połączenie identyfikowane jest przez cztery liczby: dwa numery IP oraz dwa
numery portów.\\
Pomiędzy procesami przesyłane są dwa strumienie 8-bitowych oktetów, po jednym
w każdą stronę (\textbf{strumień oktetów}). Bajty wysyłane są w
segmentach, ale proces docelowy nie jest w stanie z góry określić
wielkości nadchodzących porcji. Ilość bajtów danych przesyłanych w jednym segmencie nie powinna być większa niż ustalony MSS (\textbf{Maximum Segment Size}).\\

\textbf{Cechy TCP}
\begin{itemize}
    \item Partnerzy (procesy) tworzą połączenie z wykorzystaniem mechanizmu (trójfazowego) uzgodnienia.
    \item Zamknięcie połączenia odbywa się z wykorzystaniem mechanizmu uzgodnienia (zgoda na zamknięcie).
    \item TCP zapewnia sterowanie przepływem. Informuje partnera o tym ile bajtów danych ze strumienia danych może od niego przyjąć (okno oferowane). Rozmiar okna zmienia się dynamicznie i jest równy rozmiarowi wolnego miejsca w buforze odbiorcy. Zero oznacza, że nadawca musi zaczekać, aż program użytkowy
odbierze dane z bufora.
    \item Dane ze strumienia danych dzielone są na fragmenty, które według TCP mają najlepszy
do przesłania rozmiar. Jednostka przesyłania danych nazywa się \textbf{segmentem}.
    \item TCP zapewnia \textbf{niezawodność} połączenia.
\end{itemize}

\textbf{Mechanizmy niezawodności}
\begin{itemize}
    \item \textbf{Potwierdzanie otrzymania segmentów z mechanizmem zegara.}\\
     Odebrany segment musi być potwierdzony przez odbiorcę przez wysłanie segmentu potwierdzającego. Jeśli
potwierdzenie nie nadejdzie w odpowiednim czasie, segment zostanie przesłany powtórnie.
    \item \textbf{Sumy kontrolne.}\\
     Jeśli segment zostanie nadesłany z niepoprawna sumą kontrolną, to jest
odrzucany. Nadawca po odczekaniu odpowiedniego czasu prześle segment jeszcze raz.
    \item \textbf{Przywracanie kolejności nadchodzących segmentów.}\\
     Segmenty mogą nadchodzić w kolejności innej niż zostały wysłane, oprogramowanie TCP przywraca prawidłową kolejność przed przekazaniem do aplikacji.
     \item \textbf{Odrzucanie zdublowanych danych.}
\end{itemize}

\subsubsection{Nagłówek TCP}
\begin{itemize}
    \item \textbf{Numer sekwencji.}\\
    Dla segmentu z ustawionym tylko znacznikiem SYN w to pole wpisywany
jest (losowy) numer sekwencji początkowej (Initial Sequence Number). Taki segment jest
wysyłany w celu rozpoczęcia nawiązywania połączenia. Pierwszy oktet przesyłanych danych
ze strumienia w rzeczywistości będzie miał numer ISN+1.
W kolejnych segmentach w połączeniu TCP w polu numer sekwencji jest numer pierwszego
oktetu danych w segmencie.
Numer potwierdzenia jest ważny tylko przy włączonym znaczniku ACK. Znacznik ACK jest
włączany tylko wówczas, jeśli segment zawiera potwierdzenie odebrania jakiegoś segmentu.
Numer potwierdzenia jest to kolejny numer bajta (w strumieniu danych), którego spodziewa
się wysyłający potwierdzenie.
    \item \textbf{Długość nagłówka} (przesunięcie danych).\\
     Wielkość nagłówka wyrażona w liczbie bloków 4-bajtowych.
     \item \textbf{Jednobitowe znaczniki} (flagi):
     \begin{itemize}
         \item NS, CWR, ECE – związane z przeciwdziałaniem przeciążeniom na routerach.
         \item NS – jednobitowa suma kontrolna wartości flag związanych z
mechanizmem ECN weryfikująca ich integralność;
         \item ECE – Jeśli flaga SYN=0, to flaga ECE jest ustawiana na 1 przez odbiorcę
segmentu, jeśli segment ten dotarł w pakiecie IP z ustawionym kodem CE w bitach ECN nagłówka IP;
Jeśli SYN=1, wówczas ECE=1 oznacza, że mechanizm
ECN będzie stosowany (czyli jest to element nawiązania połączenia, w którym druga strona
połączenia jest informowana o tym, że można stosować ECN),
        \item CWR – flaga potwierdzająca odebranie ECE i
zredukowanie wielkości okna przeciążeniowego.
        \item  URG – wskaźnik ponaglenia
        \item ACK – segment potwierdzenia,
        \item PSH – segment „push” – wypchnięcie danych,
        \item RST – zresetowanie połączenia,
        \item SYN – synchronizacja,
        \item FIN – nadawca zakończył przesyłanie danych.
    \end{itemize}
    \item \textbf{Rozmiar okna.}\\
     Oznacza liczbę bajtów, które odbiorca może zaakceptować.
     \item \textbf{Suma kontrolna.}\\
      Liczona dla nagłówka i danych, z użyciem pseudonagłówka (algorytm
analogiczny jak w UDP oraz IP).
    \item \textbf{Wskaźnik ważności.}\\
     Dodatnie przesunięcie, które musi być dodane do numeru przesunięcia
sekwencyjnego pierwszego oktetu danych aby uzyskać numer ostatniego bajta szczególnie
ważnych danych w segmencie (dane te są na początku segmentu). Pole to jest brane pod
uwagę tylko, jeśli bit URG jest ustawiony na 1.
    \item \textbf{Opcje.}\\
     Rodzaj opcji (bajt), długość opcji (bajt), opcja. Najważniejsza opcja to \textbf{MSS}. Może być uzyskana jako MTU (Maximum Transmission Unit) minus rozmiar nagłówka IP oraz TCP.
\end{itemize}

\textbf{Specyfika stanu TIME WAIT}\\
Spóźnione segmenty są w czasie 2 MSL odrzucane. Para
punktów końcowych definiujących połączenie nie może być powtórnie użyta przed upływem
2MSL. Eliminuje to ewentualne kłopoty związane z odbieraniem z sieci segmentów jeszcze ze
starego połączenia.

\textbf{Półzamknięcie TCP}\\
Strona, która zakończyła połączenie i nie nadaje danych, może dane odbierać od partnera
TCP. Takie połączenie nazywane jest połączeniem półzamkniętym (half-closed).

\textbf{Segmenty RST}\\
Segment RST wysyłany jest przez oprogramowanie implementujące TCP, kiedy nadchodzi
segment niepoprawny z punktu widzenia dowolnego połączenia. Segment RST nie jest potwierdzany. W protokole UDP generowany jest komunikat ICMP o tym, że port jest nieosiągalny.
Segment RST jest wysyłany również wtedy, gdy przekroczona jest maksymalna dopuszczalna
liczba połączeń TCP.


\textbf{Połączenia półotwarte} (połowicznie otwarte)\\
Jest to połączenie nie poprawnie nawiązane. Występuje, jeśli jedna ze stron przerwała połączenie bez informowania drugiej. Segment z ustawioną na 1 flagą SYN został przesłany od
klienta do serwera, serwer odpowiedział segmentem z ustawionymi na 1 flagami SYN i ACK,
ale klient nie odpowiedział segmentem z ustawioną na 1 flagą ACK.
Jeden ze sposobów atakowania serwisów (np. WWW) polegał na otwieraniu bardzo dużej
liczby połączeń półotwartych. Obecnie implementacje TCP są odporne na tego typu ataki.
Dopuszczalne jest, by oprogramowanie realizujące TCP mogło sprawdzać stan połączenia
przez okresowe przesyłanie segmentów sprawdzających aktywność. Segment taki to zawiera
ustawioną na 1 flagę ACK i nie zawiera żadnych danych. Dodatkowo ma on ustawiony numer
sekwencyjny na o 1 mniejszy od tego, którego normalnie spodziewa się strona wysyłająca
ACK. Partner odpowiada też segmentem z ustawioną na 1 flagą ACK ze standardowo
ustawionymi prawidłowymi wartościami numerów sekwencyjnych.


\subsubsection{Opcje TCP}
\begin{itemize}
    \item \textbf{Koniec listy opcji}: 1 bajt - 0.
    \item \textbf{Brak operacji}: 1 bajt - 1. Opcja ta jest stosowana do dopełnienia pola do wielokrotności 4 bajtów.
    \item \textbf{MSS}: typ = 2, długość = 4, dane – 2 bajty ustawione na mniejszą wartość z wartości MSS podanych przez strony połączenia. MSS podawany jest w segmentach SYN.
    \item \textbf{Skala okna}: typ = 3, długość = 3, dane – 1 bajt = współczynnik skali (licnzik przesunięć), określa liczbę mnożeń przez 2 wielkości rozmiar okna, max. 14.
    \item \textbf{Pozwolenie na selektywne potwierdzanie}: typ opcji = 4, długość = 2.
    \item \textbf{Selektywne potwierdzanie}: typ = 5, długość = 10, 18, 26 lub 34 (potwierdzenie jednego, dwóch, trzech lub czterech nieciągłych bloków danych).
    \item \textbf{Sygnatury czasowe}: typ = 8, długość = 10, timestamp – 4 bajty, echo timestamp – 4 bajty.
    Stosowana jest do określania RTO (retransmission time-out).

\end{itemize}

\subsubsection{Przepływ danych w TCP}
\textbf{Potwierdzenia}
\begin{itemize}
    \item \textbf{Skumulowane potwierdzanie}\\
    Segment TCP z ustawionym znacznikiem ACK jest segmentem potwierdzającym. Numer
potwierdzenia to numer następnego bajta, który nadawca ACK spodziewa się otrzymać od nadawcy potwierdzanych danych.Taki sposób potwierdzania nie jest korzystny w
środowisku z dużą liczbą gubionych segmentów.
    \item \textbf{Opóźnione potwierdzenia}\\
    Potwierdzenie otrzymania segmentu nie jest wysyłane natychmiast. Zalety takiego podejścia
są następujące:
    \begin{itemize}
        \item Podczas trwania opóźnienia mogą zostać odebrane następne segmenty i potwierdzenie może je obejmować.
        \item Można dołączyć ACK do segmentu przesyłanych danych (piggybacking).
        \item Oprogramowanie TCP realizuje utrzymanie połączenia.
    \end{itemize}
    \item \textbf{Selektywne potwierdzenia}\\
    Realizowane przez jedną z opcji TCP. Przydaje się w łączach które są szerokopasmowe i mają duże opóźnienie. Rozmiar okna może tu być duży, nadawca może na raz transmitować dużą liczbę segmentów. Jeśli pierwszy segment zaginie, to nadawca niepotrzebnie retransmituje wszystkie. Selektywne potwierdzanie temu zapobiega.
\end{itemize}

\textbf{Ruchome okna TCP} (sliding windows)\\
Połączenie TCP obejmuje dwa strumienie danych. W każdym strumieniu określony jest
nadawca i odbiorca. Kontrolę przesyłania oktetów w strumieniu umożliwiają mechanizmy
tzw. przesuwnych (ruchomych) okien, które można sobie wyobrazić jako nałożone na
strumień. Dla strumienia określone jest okno nadawcy oraz okno odbiorcy. Nadawca może
wysyłać tylko te dane, które są w tej chwili w jego oknie nadawczym, przy czym może to
zrobić tylko za zgodą odbiorcy. Okno nadawcze jest przesuwane nad wyjściowym
strumieniem bajtów, okno odbiorcze nad strumieniem wejściowym.

\textbf{Okno nadawcze}
Nadawca określa, które oktety w jego strumieniu wyjściowym zostały:
\begin{itemize}
    \item wysłane i potwierdzone,
    \item wysłane, ale jeszcze nie potwierdzone,
    \item jeszcze nie wysłane, ale już znajdujące się w oknie nadawczym
    \item jeszcze nie wysłane i znajdujące się poza oknem nadawczym
\end{itemize}
Dane w oknie nadawczym mogą być wysłane przez nadawcę, gdyż odbiorca na to zezwolił, lub jeszcze raz wysyłane wskutek realizacji strategii powolnego startu lub zapobiegania zatorom.
Okno nadawcze rozciąga się od oktetu, którego spodziewa się partner w ostatnim
potwierdzeniu ACK.\\
Okno nadawcze ma lewą i prawą krawędź. W trakcie potwierdzania kolejnych segmentów
lewa krawędź okna nadawczego przesuwa się w prawo powodując tzw. zamykanie okna. Jeśli
numer potwierdzenia + rozmiar okna wskazują na konieczność przesunięcia prawej krawędzi,
to jest ona przesuwana powodując tzw. otwieranie okna.\\
Jeśli bufor odbiorczy się wypełni to odbiorca przesyła z
potwierdzeniem ostatniego segmentu proponowany rozmiar okna równy zero.
Kiedy bufor odbiorczy zostane całkowicie opróżniony odbiorca wysyła
„zbędny” segment ACK bez danych i z numerem potwierdzenia takim jak poprzedni ACK. Ten
segment nie jest potwierdzany ani retransmitowany.\\

\textbf{Okno odbiorcze}
Odbiorca określa, które oktety w jego strumieniu wejściowym zostały:
\begin{itemize}
    \item odebrane, potwierdzone i pobrane do warstwy aplikacji
    \item odebrane, potwierdzone, ale jeszcze nie pobrane do warstwy aplikacji
    \item odebrane, ale jeszcze nie potwierdzone
    \item nie odebrane, ale znajdujące się w tzw. bieżącym oknie odbiorczym (wolna przestrzeń buforu odbiorczego)
    \item nie odebrane i znajdujące się poza oknem odbiorczym (nie zostaną odebrane)
\end{itemize}

Maksymalne okno odbiorcze obejmuje wszystkie oktety odebrane. Ma ono stałą wielkość równą buforowi do
odbierania danych w połączeniu TCP. Bieżące okno odbiorcze obejmuje odebrane niepotwierdzone i będące w bieżącym oknie odbiorczym. \\
Ze względu na to, że oktety są ponumerowane łatwo można
określić, w którym miejscu strumienia powinny się znaleźć. W każdym segmencie jest
przekazywany numer pierwszego oktetu danych.
Bieżące okno odbiorcze ma lewą i prawą krawędź, analogicznie jak dla okna nadawczego. Prawa krawędź odbiorczego okna bieżącego pokrywa się z prawą krawędzią maksymalnego okna odbiorczego. Jeśli aplikacja
odbiera dane z bufora, to krawędź ta przesuwa się w prawo (podobnie jak lewa krawędź
maksymalnego okna odbiorczego). Potwierdzanie ACK przesuwa lewą krawędź okna
bieżącego w prawo.\\

\subsubsection{Przesyłanie małych segmentów}
Tak określa się segmenty o rozmiarze mniejszym od MSS.
Przesyłanie małych segmentów zmniejsza efektywność sieci.
Aby temu zapobiec stosowane są takie mechanizmy, jak algorytm Nagle’a i unikanie
„syndromu głupiego okna”.
\begin{itemize}
    \item \textbf{Algorytm Nagle’a}\\
    „Dopasowuje się” do sieci, w której przesyłane są segmenty.
    \begin{itemize}
        \item TCP powinno przesyłać tylko pojedyncze małe niepotwierdzone segmenty.
        \item W czasie oczekiwania na potwierdzenie, dane są gromadzone w buforze.
        \item W sieci o szerokim paśmie i małym opóźnieniu akumulacja jest mała, efektywność
        mniejsza, ale kompensowana szybkością sieci. W sieciach o małym paśmie i dużych
        opóźnieniach akumulacja zwiększa efektywność.
    \end{itemize}
    Algorytm Nagle’a może być wyłączany przez oprogramowanie TCP.
    \item \textbf{Syndrom głupiego okna} (SWS)\\
    \begin{itemize}
        \item Jeśli odbiorca ma zerowy rozmiar okna (i nadawca też) oraz warstwa aplikacji pobierze 1
        bajt, to okno odbiorcze otwiera się o jeden bajt.
        \item Odbiorca może wysłać ACK z proponowaną wielkością okna równą 1. Gdyby tak było, to
        druga strona połączenia też powiększy okno nadawcze o jeden bajt i prześle segment
        zawierający 1 bajt danych itd.
        \item Aby uniknąć SWS odbiorca ogłasza nowy rozmiar okna dopiero, gdy rozmiar ten wynosi co
        najmniej MSS lub połowę maksymalnego rozmiaru okna odbiorczego.
        \item Nadawca unika SWS wstrzymując się z wysyłaniem danych dopóki rozmiar okna proponowanego przez odbiorcę nie jest równy co najmniej MSS. „Interaktywne” dane mogą być wysyłane z flagą PSH wg algorytmu Nagle’a.
    \end{itemize}
\end{itemize}

\textbf{Dodatkowa kontrola przepływu po stronie nadawcy}\\
Nadawca może przesłać wszystkie segmenty, które znajdują się w oknie nadawczym. Takie działanie może jednak doprowadzić do zatorów. Poniższe algorytmy bazują na pojęciu okna przeciążeniowego (okna zatoru, congestion window) i zapobiegają zatorom oraz powodują unikanie powtórnej zapaści.
\begin{itemize}
    \item \textbf{Algorytm powolnego startu}\\
    Po otwarciu połączenia lub dłuższym czasie nie przesyłania danych wielkość okna
przeciążeniowego ustawiana jest na 2*MSS. Każde przychodzące potwierdzenie (ACK)
powoduje zwiększenie okna przeciążeniowego o jeden MSS. Może to prowadzić do wykładniczego wzrostu wielkości tego okna Rozmiar okna nadawczego ustalany jest jako minimum z wielkości okna przeciążeniowego
oraz ogłoszonego przez odbiorcę bieżącego okna przeciążeniowego.
    \item \textbf{Algortym unikania zatoru}\\
Tu stosuje się wolniejszy wzrost wielkości okna przeciążeniowego, np. o jeden
segment na kilka przychodzących ACK. Algorytm ten działa zwykle od pewnego progu (najpierw działa powolny start).
\end{itemize}


\subsubsection{Retransmisje segmentów w TCP}
W każdym połączeniu definiowana jest zmienna RTO (Retransmission Time-out). Jeśli TCP nie
odbierze ACK w czasie RTO dla pewnego nadanego segmentu, to segment musi być
retransmitowany. RTO powinien być większy od stale obliczanego RTT (Round Trip Time).
Segmenty ACK (bez danych) nie są potwierdzane.
Wyznaczenie prawidłowej wartości RTO jest ważne dla uniknięcia zapaści spowodowanej
przeciążeniem (np. RTT rośnie szybciej niż wyliczany RTO, segmenty będą retransmitowane
co jeszcze zwiększy ruch w sieci).

\textbf{Zasady retransmisji}
Jeśli nie określono innych: dla początkowego segmentu przyjmuje się bieżące znane RTO dla
połączenia. Po upłynięciu RTO wartość RTO jest podwajana, a segment wysyłany ponownie.

Potwierdzenie dla retransmitowanego segmentu jest niejednoznaczne, nie wiadomo czy jest
to opóźnione potwierdzenie pierwszej kopii, czy potwierdzenie drugiej kopii.
Rodzi to problemy z szacowanym RTT.
\textbf{Niejednoznaczność potwierdzenia – Algorytm Karna}
Pomiary RTT dla retransmitowanych segmentów są pomijane. Może to rodzić problemy, jeśli
RTT gwałtownie wzrośnie. Dlatego tymczasowo stosowane jest dublowanie RTO dla
kolejnych retransmitowanych segmentów. Dopiero przyjęcie ACK segmentu nie
retransmitowanego powoduje obliczenie RTT i RTO dla tego nowego czasu RTT.

\section{Informacje uzupełniające}
\subsubsection{Szerokość pasma}
W sieciach komputerowych termin ten oznacza na ogół liczbę bitów, które mogłyby być
przesłane w danej technologii w ciągu sekundy. Może oznaczać również częstotliwość zegara
taktującego, wykorzystywanego w danej technologii sieciowej.

\subsection{Przepustowość}
Przepustowość jest miarą ilości użytecznej informacji dostarczonej z sukcesem przez ścieżkę
komunikacyjną. Przepustowość odnosi się do mierzonej efektywności systemu, np. łącze o
szerokości pasma 100 Mb/s może osiągnąć przepustowość np. 70 Mb/s, ze względu na
implementację, wykorzystane protokoły, szyfrowanie itd.\\

W zależności od tego czy uwzględnia się narzut związany z technologią, narzut związany z protokołami komunikacyjnymi definiuje się różne odmiany przepustowości.
\begin{itemize}
    \item \textbf{Przepustowość maksymalna}
    \begin{itemize}
        \item maximum theoretical throughput - największa możliwa do przesłania liczba bitów danych w jednostce czasu; do tych bitów NIE wlicza się narzutu warstwy pierwszej i drugiej,
        \item peak measured throughput -wartość mierzona w rzeczywistym systemie lub na symulatorze w krótkim odcinku czasu,
        \item maximum sustained throughput - średnia wartość dla długotrwałych obciążeń.
    \end{itemize}
    \item \textbf{Efektywna przepustowość} (Goodput, przepustowość warstwy aplikacji)\\
    \begin{itemize}
        \item Mierzy liczbę bitów danych efektywnie przesłanych w warstwie aplikacji w jednostce czasu.
        \item Iloraz liczby bitów dostarczonych w warstwie aplikacji do czasu mierzonego od wysłania pierwszego do dostarczenia ostatniego przesłanego bitu.
        \item Nie zalicza się narzutu związanego z technologią warstwy drugiej i pierwszej, protokołami z warstw wyższych, niezawodnością.
    \end{itemize}
\end{itemize}

\subsection{Pozostałe}
\begin{itemize}
    \item \textbf{Opóźnienie} - w sieciach z przełączaniem pakietów oznacza czas, jaki
mija od wysłania pakietu do odebrania go przez adresata. Może być mierzony w jedną stronę
(one way) lub w dwie (round-trip delay time).
    \item \textbf{Zmienność opóźnienia} - miara krótkotrwałych zmian w opóźnieniu.
Duża zmienność ma bardzo niekorzystny wpływ np. na jakość transmitowanego dźwięku.
    \item \textbf{Czas propagacji} - czas w jakim sygnał pokona pewną odległość w
    medium transmisyjnym.
    \item \textbf{Czas transmisji} - czas jaki zajmuje umieszczenie pakietu w
medium transmisyjnym.
    \item \textbf{Opóźnienie przekazania} - czas jaki mija od odebrania pakietu
przez urządzenie (przekazujące pakiet) do momentu, gdy pakiet może być wysłany.
    \item \textbf{Czas przetwarzania} - czas w jakim pakiet jest przetwarzany w
urządzeniu, obejmuje np. wykonanie zmian w nagłówkach, wyznaczenie routera następnego
skoku itd.
    \item \textbf{Niezawodność sieci}
    \item \textbf{Współczynnik gubienia pakietów}, Packet Loss Ratio (PLR) - iloraz liczby straconych
pakietów do całkowitej liczby pakietów przesłanych w pewnym czasie.
\end{itemize}

\section{DNS}

Oprócz adresu IP komputer ma
przyporządkowaną \textbf{nazwę}. Konwencje nazywania komputerów:
\begin{itemize}
    \item \textbf{nazwy hosta}\\
    W czasach gdy istniała sieć ARPAnet każdy komputer miał przydzieloną własną
unikalną nazwę. Nazwy wszystkich komputerów były przechowywane w pliku HOSTS.TXT.
Plik ten musiał być ręcznie aktualizowany i centralnie zarządzany oraz rozsyłany z centrum
do lokalnych komputerów.
    \item \textbf{nazwy DNS}\\
    Domain Name System – system nazw domenowych, który jest rozproszonym systemem
przechowującym informacje o nazwach komputerów i ich numerach IP. System ten zawiera
mechanizmy tłumaczenia nazw. Dane DNS przechowywane są na serwerach nazw. Serwer DNS jest
odpowiedzialny za swój fragment sieci i udostępnia swoje dane innym serwerom. DNS jest systemem hierarchicznym i jego strukturę można przedstawić w
postaci drzewa. Termin domena DNS jest często utożsamiany z poddrzewem drzewa DNS. Dostęp do serwera DNS jest realizowany przez mechanizm określany czasem jako resolver.

    \item \textbf{nazwy NetBIOS}.

\end{itemize} 

Istnieją mechanizmy tłumaczące nazwy na numery IP i odwrotnie.
Ciałem odpowiedzialnym za koordynację nazw domen górnego poziomu a także
odpowiedzialnym za przypisywanie adresów IP jest IANA Internet Assigned Numbers
Authority.
Ciałem nadzorującym od strony technicznej różne działania związane z uzyskiwaniem
(rejestrowaniem) nazw domen, numerów Ip, numerów portów jest ICANN - Internet
Corporation for Assigned Names and Numbers.

\textbf{Domeny górnego poziomu}
\begin{itemize}
    \item arpa - specjalna, wykorzystywana do odwzorowania adresów IP w nazwy.
    \item Domeny podstawowe (generic, gTLD), np: com, edu, gov.
    \item Domeny geograficzne (krajowe, country-code ccTLD), np: pl, uk, de.
\end{itemize}

\textbf{Domeny drugiego poziomu} - w wielu krajach domeny drugiego poziomu odzwierciedlają
domeny organizacyjne pierwszego poziomu, ale ujmowane na swoim terytorium. Przykłady:
edu.pl, com.pl, co.uk, ac.uk.

W DNS (np. w plikach konfiguracyjnych) występują często tzw. \textbf{absolutne nazwy domeny},
inaczej w pełni określone nazwy domeny (FQDN). FQDN jest to nazwa domeny zakończona kropką (np. ii.uj.edu.pl. ). Jeśli nazwa nie
jest zakończona kropką, to może być jakoś uzupełniana.

Obszar, inaczej \textbf{strefa} (zone) jest częścią systemu DNS, która jest oddzielnie administrowana.
Domeny drugiego poziomu dzielone są na mniejsze strefy. Z kolei te strefy mogą być dalej
dzielone. Występuje tu delegowanie zarządzania w dół struktury drzewa. Jednostka
odpowiedzialna za zarządzanie daną strefą decyduje ile będzie serwerów DNS w strefie,
rejestruje i udostępnia nazwy i numery IP nowych komputerów zainstalowanych w strefie.
W tej chwili jest na świecie 13 (typów) serwerów głównych (najwyższego poziomu) zwanych
po angielsku root-servers, posiadającymi nazwy od a.root-servers.net do m.root-servers.net.

\textbf{Poszukiwania w DNS}
\begin{itemize}
\item Proste, „do przodu”– klient zna nazwę domenową, a chce uzyskać numer IP.
\item Odwrotne (reverse) – klient zna adres IP i chce uzyskać nazwę domenową.
Przeszukiwanie odwrotne wykorzystuje domenę arpa.in-addr. Jeśli chcemy
poznać nazwę domenową komputera, to w systemie DNS adres ten
jest reprezentowany jako specyficzna nazwa w domenie arpa.in-addr.
\end{itemize}

\subsection{Typy serwerów DNS}
W każdej strefie musi być uruchomiony podstawowy serwer DNS oraz pewna liczba
serwerów drugoplanowych, zapewniających usługi w razie awarii serwera podstawowego.
Serwer podstawowy pobiera dane z pliku konfiguracyjnego, natomiast serwery
drugoplanowe uzyskują dane od serwera podstawowego na drodze tzw. transferu strefy
(zone transfer). Serwery drugoplanowe odpytują serwer podstawowy o dane w sposób
regularny, zwykle co kilka godzin. Oprócz dwóch wymienionych rodzajów serwerów są
jeszcze serwery podręczne (lokalne), których zadaniem jest zapamiętanie na pewien czas w
pamięci podręcznej danych uzyskanych od innych serwerów tak, aby kolejne zapytania
klientów mogły być obsłużone lokalnie.
Serwery DNS działają na portach 53 UDP oraz 53 TCP. Na ogół w warstwie transportu
używany jest UDP. Wyjątkiem jest m.in. transmisja danych z serwera podstawowego do
drugoplanowego (większe porcje danych) oraz komunikaty w sieciach WAN. Również kiedy w 
odpowiedzi od serwera (przez UDP) ustawiony jest bit TC (patrz niżej) ponawiane jest
zapytanie z wykorzystaniem TCP.

\textbf{Podział ze względu na sposób uzyskania odpowiedzi poszukiwania}
\begin{itemize}
    \item Przeszukiwanie rekurencyjne – klient oczekuje od serwera żądanej informacji. W przypadku,
gdy serwer nie przechowuje żądanej informacji, sam znajduje ją na drodze wymiany
komunikatów z innymi serwerami.
    \item  Przeszukiwanie iteracyjne – występuje między lokalnym serwerem DNS a innymi serwerami
DNS. Jeśli odpytywany serwer nie zna szukanego adresu IP, odsyła pytającego do innych
serwerów (odpowiedzialnych za daną domenę).
\end{itemize}

\textbf{Komunikacja klienta z serwerem DNS}\\
Przy odwołaniu do nazwy domenowej system zwykle najpierw sprawdza, czy nie jest to
nazwa hosta lokalnego, następnie sprawdza plik hosts - o ile istnieje. Jeśli nie znajdzie odpowiedniego wpisu, to
wysyłane jest zapytanie do pierwszego serwera DNS (adres w pliku
konfiguracyjnym). 

\textbf{Standardowy sposób poszukiwania}\\
Klient pyta swój domyślny serwer DNS wysyłając zapytanie rekurencyjne.
Odpytany serwer realizuje zapytania iteracyjne, zaczynając od serwerów głównych, które
odsyłają do serwerów niższego poziomu.
Mechanizm ten może się wydawać nieefektywny, ale w rzeczywistości dzięki temu, że
serwery DNS zapamiętują na pewien czas informacje uzyskane z innych serwerów DNS
(cache), często odpowiedź na zapytanie programu-klienta zostaje znaleziona bardzo szybko.

\textbf{Dynamiczny DNS (DDNS)}\\
Chyba najważniejsze wpisy w DNS dotyczą serwisów, np. www. Standardowo DNS obsługuje
odwzorowanie nazw do statycznych adresów IP. Można jednak skonfigurować odwzorowanie dla adresów zmieniających się
dynamicznie. W tym celu należy skorzystać z odpowiednich usługodawców w Internecie,
którzy przypisują nazwę do swojego IP i pewnego numeru portu, następnie zapytanie
przekierowują do komputera ze zmiennym IP z ewentualną zmianą portu. Na komputerze ze zmiennym IP należy
zainstalować odpowiedni program (klient DDNS), który będzie powiadamiał serwer DDNS o
zmianach adresu IP.
Oddzielnym problemem, który należy rozwiązać, jest wykorzystanie serwera NAT i
przypisywanie adresów prywatnych do serwisu w sieci. Na ogół wystarczy odpowiednie
działanie klienta DDNS oraz odpowiednie skonfigurowanie serwera NAT.

\subsection{Przykładowe konfiguracje serwerów DNS}
Przykładowy plik /etc/resolv.conf (Unix)
nameserver 149.156.78.3
nameserver 149.156.78.95
domain xx.yy.edu.pl
Podstawowe wpisy to – po słowie nameserver – numery IP kolejnych serwerów DNS, które
mają być odpytywane w przypadku braku odpowiedzi od poprzedniego.
Linia ze słowem domain oznacza domenę domyślną (tzn. co ma być dołączone do nazwy
hosta w przypadku, gdy nie określono domeny, np. ftp gandalf).
Może się pojawić linia podobna do domain, ze słowem search, po którym jest (maksymalnie
sześć) nazw domen. Taka linia oznacza, że poszukiwania mają być prowadzone dla nazw z
dołączonymi kolejno nazwami podanych domen.


Plik konfiguracyjny serwera named (bind): /etc/named.boot lub /etc/named.conf.
Główną częścią BIND jest proces o nazwie „named”.
Skonfigurowanie bind może polegać na utworzeniu m.in. pliku /etc/named.conf. Pliki te zawierają opcje działania programu i informacje o plikach
stref. 
W zone lub options może się pojawić dyrektywa allow-query,
która ogranicza adresy IP, z których mogą pochodzić zapytania.
W katalogu /var/named należy utworzyć pliki stref, np. xx.yy.edu.pl
Po każdorazowej zmianie w plikach konfiguracyjnych należy serwis restartować.
Proces named powinien być startowany nie z prawami roota, tzn. należy utworzyć konto
named, zamiast domyślnego shella.

\subsection{Rekordy zasobów}
Każdy serwer DNS przechowuje informacje o tej części obszaru nazw DNS, dla której jest
autorytatywny (administratorzy są odpowiedzialni za poprawność informacji). Informacje
zapisywane są w postaci tzw. rekordów zasobów.
Dla zwiększenia wydajności serwer DNS może przechowywać również rekordy zasobów
domen z innej części drzewa domen.
\textbf{Istnieje szereg typów rekordów zasobów:}\\
SOA (Start of Authority) Rekord uwierzytelnienia – pierwszy rekord w pliku
strefy, określa podmiot odpowiedzialny od tego punktu hierarchii „w dół”.
    \begin{itemize}
        \item Serial – pole zawierające numer wersji pliku strefy, zwykle w polu tym odzwierciedlona jest
data oraz numer wersji pliku w danym dniu.
        \item Refresh – określa jak często serwer pomocniczy ma sprawdzać na serwerze podstawowym,
czy nie zachodzi potrzeba uaktualnienia plików.
        \item Retry – czas, po którym serwer pomocniczy będzie ponownie próbował odtworzyć dane po
nieudanej próbie odświeżenia.
        \item Expire – maksymalny limit czasu, przez który serwer pomocniczy może utrzymywać dane w
pamięci cache bez ich uaktualnienia.
Minimum (Default TTL) – domyślny czas, jaki ma być użyty dla rekordów, które nie mają
określonego TTL.
    \end{itemize}

\subsection{DHCP - Dynamic Host Configuration Protocol}
Wadą BOOTP jest statyczny sposób przydzielania numerów IP.
Przydział dynamiczny umożliwia pracę (ale nie jednoczesną) wielu komputerów z
przydzielonym jednym numerem IP.
Serwer DHCP przydziela adresy IP dynamicznie. Obecnie w bardzo wielu sieciach lokalnych
komputery nie mają na stałe wpisanych IP, ale pobierają IP od serwera DHCP w momencie
startu systemu.
Serwer DHCP może wykorzystywać różne sposoby przypisywania adresów:
\begin{itemize}
    \item przydział statyczny IP do danego komputera (ustawienie „ręczne”, danemu adresowi
MAC jest przypisywany stale jeden na stałe wybrany IP),
    \item automatyczny przydział statyczny przy pierwszym starcie komputera i kontakcie z
serwerem,
    \item przydział dynamiczny, w którym serwer wynajmuje adres IP na określony czas.
DHCP umożliwia budowanie systemów konfigurujących się automatycznie.
Oprócz przydzielenia adresu IP serwer DHCP przesyła do komputera klienta również 
\end{itemize}

\section{EIGRP}

\subsection{System autonomiczny (AS)}
Pojęcie System Autonomiczny w sieciach komputerowych jest używane w różnych
znaczeniach. Główne znaczenie związane jest z protokołem routowania zewnętrznego BGP
(Border Gateway Protocol). AS pojawia się również w protokołach routowania wewnętrznego, np. w IGRP i EIGRP.\\
Nazwę AS wyjaśnia dokument RFC 1930: „The classic definition of an Autonomous System is a set of routers
under a single technical administration, using an interior gateway
protocol and common metrics to route packets within the AS, and using an
exterior gateway protocol to route packets to other ASes. Since this
classic definition was developed, it has become common for a single AS to
use several interior gateway protocols and sometimes several sets of
metrics within an AS. The use of the term Autonomous System here stresses
the fact that, even when multiple IGPs and metrics are used, the
administration of an AS appears to other ASes to have a single coherent
interior routing plan and presents a consistent picture of what networks
are reachable through it.”
I dalej:
„An AS is a connected group of one or more IP prefixes run by one or more
network operators which has a SINGLE and CLEARLY DEFINED routing policy.”
Użyty tu termin prefiks określa sieć (lub sumę, agregację sieci) i oznacza pewną liczbę
najbardziej znaczących bitów adresu IPv4 lub IPv6. W IPv6 termin ten jest powszechnie
używany do określania sieci i zastępuje złożenie adresu IPv4 i maski.
Zatem system autonomiczny oznacza grupę złożoną z jednego lub większej liczby prefiksów
sieci należących do jednego lub więcej operatorów, która to grupa ma jedną jasno
zdefiniowaną politykę routowania.
Protokołem routowania zewnętrznego (tj. między systemami autonomicznymi) jest obecnie
BGP4.
Numery AS są 2 bajtowe (0-65535), a od 2007 roku również 4 bajtowe.
W niektórych protokołach routowania wewnętrznego należy określić identyfikator procesu. W EIGRP jest on określony jako Autonomous
System number. Numer ten jednak nie musi być unikalny w skali świata i nie jest
przekazywany do protokołu routowania zewnętrznego (BGP4). Jeśli zarządca pewnego
obszaru wykorzystuje BGP4 i ma przydzielony numer AS, wówczas numer ten może być użyty
w EIGRP jako numer procesu. Jeśli protokół routowania zewnętrznego nie jest
wykorzystywany, to można używać numeru np. z zakresu numerów prywatnych (64512-
65535) lub nawet wykorzystać własną numerację.

\subsection{Protokół IGRP}
IGRP jest protokołem wektora odległości. IGRP przy konfiguracji wymaga podania numeru
systemu autonomicznego AS -  pewnego numeru
określającego numer procesu IGRP. Numer ten musi być taki sam we
wszystkich routerach, które na pewnym obszarze komunikują się przy pomocy IGRP.
IGRP został utworzony przez firmę Cisco jako rozwiązanie pewnych problemów związanych
ze stosowaniem RIP – głównie chodziło o rozróżnienie między technologiami sieciowymi o
różnych przepustowościach.
\textbf{IGRP nie jest już wspierany przez firmę Cisco, jest wycofany. Zastąpił go protokół EIGRP.}
Metryka w IGRP jest tworzona na podstawie wartości metryk cząstkowych oraz zmiennych
określających wagę każdej użytej metryki. \\



\end{document}
